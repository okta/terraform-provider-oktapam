package oktapam

import (
	"context"

	"github.com/okta/terraform-provider-oktapam/oktapam/client"
	"github.com/okta/terraform-provider-oktapam/oktapam/constants/attributes"
	"github.com/okta/terraform-provider-oktapam/oktapam/constants/descriptions"
	"github.com/okta/terraform-provider-oktapam/oktapam/logging"
	"github.com/okta/terraform-provider-oktapam/oktapam/utils"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceADConnection() *schema.Resource {
	return &schema.Resource{
		Description:   descriptions.ResourceADConnection,
		CreateContext: resourceADConnectionCreate,
		ReadContext:   resourceADConnectionRead,
		UpdateContext: resourceADConnectionUpdate,
		DeleteContext: resourceADConnectionDelete,
		Schema: map[string]*schema.Schema{
			attributes.Name: {
				Type:        schema.TypeString,
				Required:    true,
				Description: descriptions.Name,
			},
			attributes.ID: {
				Type:     schema.TypeString,
				Computed: true,
				// Description is autogenerated
			},
			attributes.GatewayID: {
				Type:        schema.TypeString,
				Required:    true,
				Description: descriptions.GatewayID,
			},
			attributes.Domain: {
				Type:        schema.TypeString,
				Required:    true,
				Description: descriptions.Domain,
			},
			attributes.ServiceAccountUsername: {
				Type:        schema.TypeString,
				Required:    true,
				Description: descriptions.ServiceAccountUsername,
			},
			attributes.ServiceAccountPassword: {
				Type:        schema.TypeString,
				Required:    true,
				Description: descriptions.ServiceAccountPassword,
			},
			attributes.UsePasswordless: {
				Type:        schema.TypeBool,
				Default:     false,
				Optional:    true,
				Description: descriptions.UsePasswordless,
			},
			attributes.CertificateID: {
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true, //In case, certificate Id is not provided and passwordless is true, it's generated.
				Description: descriptions.CertificateID,
			},
			attributes.DomainControllers: {
				Type: schema.TypeSet,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
				Optional:    true,
				Description: descriptions.DomainControllers,
			},
			attributes.DeletedAt: {
				Type:        schema.TypeString,
				Computed:    true,
				Description: descriptions.DeletedAt,
			},
		},
		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
	}
}

func resourceADConnectionCreate(ctx context.Context, d *schema.ResourceData, m any) diag.Diagnostics {
	c := getLocalClientFromMetadata(m)

	//Build ADConnection API Request Object
	var domainControllers []string
	if v, ok := d.GetOk(attributes.DomainControllers); ok && v.(*schema.Set).Len() > 0 {
		domainControllers = utils.ExpandStringSet(v.(*schema.Set))
	}

	adConnectionReq := client.ADConnection{
		Name:                   GetStringPtrFromResource(attributes.Name, d, false),
		GatewayID:              GetStringPtrFromResource(attributes.GatewayID, d, false),
		Domain:                 GetStringPtrFromResource(attributes.Domain, d, false),
		ServiceAccountUsername: GetStringPtrFromResource(attributes.ServiceAccountUsername, d, false),
		ServiceAccountPassword: GetStringPtrFromResource(attributes.ServiceAccountPassword, d, false),
		UsePasswordless:        GetBoolPtrFromResource(attributes.UsePasswordless, d, true),
		CertificateId:          GetStringPtrFromResource(attributes.CertificateID, d, false),
		DomainControllers:      domainControllers,
	}

	//Call api client
	if createdADConn, err := c.CreateADConnection(ctx, adConnectionReq); err != nil {
		return diag.FromErr(err)
	} else if createdADConn == nil {
		d.SetId("")
	} else {
		//Set returned id
		d.SetId(*createdADConn.ID)
	}

	return resourceADConnectionRead(ctx, d, m)
}

func resourceADConnectionRead(ctx context.Context, d *schema.ResourceData, m any) diag.Diagnostics {
	var diags diag.Diagnostics
	c := getLocalClientFromMetadata(m)

	adConnectionId := d.Id()
	adConnection, err := c.GetADConnection(ctx, adConnectionId, false)
	if err != nil {
		return diag.FromErr(err)
	}

	if adConnection != nil && utils.IsNonEmpty(adConnection.ID) {
		for key, value := range adConnection.ToResourceMap() {
			if err := d.Set(key, value); err != nil {
				diags = append(diags, diag.FromErr(err)...)
			}
		}
	} else {
		logging.Infof("ADConnection %s does not exist", adConnectionId)
	}

	return diags
}

func resourceADConnectionUpdate(ctx context.Context, d *schema.ResourceData, m any) diag.Diagnostics {
	c := getLocalClientFromMetadata(m)
	adConnId := d.Id()

	if d.HasChanges(attributes.Name, attributes.GatewayID, attributes.Domain, attributes.DomainControllers,
		attributes.UsePasswordless, attributes.CertificateID, attributes.ServiceAccountUsername, attributes.ServiceAccountPassword) {
		//Build ADConnection
		var domainControllers []string
		if v, ok := d.GetOk(attributes.DomainControllers); ok && v.(*schema.Set).Len() > 0 {
			domainControllers = utils.ExpandStringSet(v.(*schema.Set))
		}

		//Build API Client Request Object
		adConnectionReq := client.ADConnection{
			Name:                   GetStringPtrFromResource(attributes.Name, d, false),
			GatewayID:              GetStringPtrFromResource(attributes.GatewayID, d, false),
			Domain:                 GetStringPtrFromResource(attributes.Domain, d, false),
			ServiceAccountUsername: GetStringPtrFromResource(attributes.ServiceAccountUsername, d, false),
			ServiceAccountPassword: GetStringPtrFromResource(attributes.ServiceAccountPassword, d, false),
			UsePasswordless:        GetBoolPtrFromResource(attributes.UsePasswordless, d, true),
			CertificateId:          GetStringPtrFromResource(attributes.CertificateID, d, false),
			DomainControllers:      domainControllers,
		}

		_, err := c.UpdateADConnection(ctx, adConnId, adConnectionReq)
		if err != nil {
			return diag.FromErr(err)
		}
	}

	return resourceADConnectionRead(ctx, d, m)
}

func resourceADConnectionDelete(ctx context.Context, d *schema.ResourceData, m any) diag.Diagnostics {
	var diags diag.Diagnostics
	c := getLocalClientFromMetadata(m)
	adConnId := d.Id()

	err := c.DeleteADConnection(ctx, adConnId)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId("")
	return diags
}
