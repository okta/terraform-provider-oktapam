package oktapam

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/okta/terraform-provider-oktapam/oktapam/client"
	"github.com/okta/terraform-provider-oktapam/oktapam/constants/attributes"
	"github.com/okta/terraform-provider-oktapam/oktapam/constants/descriptions"
)

func resourceSecurityPolicy() *schema.Resource {
	return &schema.Resource{
		Description:   "SECURITY POLICY DESCRIPTION", // TODO: change this
		CreateContext: resourceSecurityPolicyCreate,
		ReadContext:   resourceSecurityPolicyRead,
		DeleteContext: resourceSecurityPolicyDelete,
		UpdateContext: resourceSecurityPolicyUpdate,
		Schema: map[string]*schema.Schema{
			attributes.ID: {
				Type:     schema.TypeString,
				Computed: true,
				// Description is autogenerated
			},
			attributes.Name: {
				Type:        schema.TypeString,
				Required:    true,
				Description: descriptions.Name,
				// TODO: validation function
			},
			attributes.Description: {
				Type:        schema.TypeString,
				Optional:    true,
				Description: descriptions.Description,
			},
			attributes.Active: {
				Type:        schema.TypeBool,
				Required:    true,
				Description: "", // TODO: add description
			},
			attributes.Principals: {
				Type:        schema.TypeList,
				Required:    true,
				MinItems:    1,
				MaxItems:    1,
				Description: "", // TODO: add description
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						attributes.Users: {
							Type: schema.TypeList,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "", // TODO: add description
						},
						attributes.Groups: {
							Type: schema.TypeList,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: "", // TODO: add description
						},
					},
				},
			},
			attributes.Rule: {
				Type:        schema.TypeList,
				Required:    true,
				MinItems:    1,
				MaxItems:    20,
				Description: "", // TODO: add description
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						attributes.ID: {
							Type:     schema.TypeString,
							Computed: true,
						},
						attributes.Name: {
							Type:        schema.TypeString,
							Required:    true,
							Description: descriptions.Name,
						},
						attributes.Resources: {
							Type:        schema.TypeList,
							Required:    true,
							MinItems:    1,
							MaxItems:    1,
							Description: "", // TODO: add description
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									attributes.Servers: {
										Type:        schema.TypeList,
										Required:    true, // TODO: when we have other resource type, this would be optional?
										MinItems:    1,
										MaxItems:    1,
										Description: "", // TODO: add description
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												attributes.Server: {
													Type:        schema.TypeList,
													Optional:    true,
													Description: "", // TODO: add description
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															attributes.ServerId: {
																Type:        schema.TypeString,
																Required:    true,
																Description: "", // TODO: add description
															},
														},
													},
												},
												attributes.ServerAccount: {
													Type:        schema.TypeList,
													Optional:    true,
													Description: "", // TODO: add description
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															attributes.ServerId: {
																Type:        schema.TypeString,
																Required:    true,
																Description: "", // TODO: add description
															},
															attributes.Username: {
																Type:        schema.TypeString,
																Required:    true,
																Description: "", // TODO: add description
															},
														},
													},
												},
												attributes.LabelSelectors: {
													Type:        schema.TypeList,
													Optional:    true,
													MaxItems:    1,
													Description: "", // TODO: add description
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															attributes.ServerLabels: {
																Type:        schema.TypeMap,
																Required:    true,
																Description: "", // TODO: add description
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
															attributes.Usernames: {
																Type:        schema.TypeList,
																Optional:    true,
																Description: "", // TODO: add description
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						attributes.Privileges: {
							Type:        schema.TypeList,
							Required:    true,
							MinItems:    1,
							MaxItems:    1,
							Description: "", // TODO: add description
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									attributes.PasswordCheckoutRDP: {
										Type:        schema.TypeList,
										Optional:    true,
										MaxItems:    1,
										Description: "", // TODO: add description
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												attributes.Enabled: {
													Type:        schema.TypeBool,
													Required:    true,
													Description: "", // TODO: add description
												},
											},
										},
									},
									attributes.PasswordCheckoutSSH: {
										Type:        schema.TypeList,
										Optional:    true,
										MaxItems:    1,
										Description: "",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												attributes.Enabled: {
													Type:        schema.TypeBool,
													Required:    true,
													Description: "", // TODO: add description
												},
											},
										},
									},
									attributes.PrincipalAccountRDP: {
										Type:        schema.TypeList,
										Optional:    true,
										MaxItems:    1,
										Description: "",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												attributes.Enabled: {
													Type:        schema.TypeBool,
													Required:    true,
													Description: "", // TODO: add description
												},
											},
										},
									},
									attributes.PrincipalAccountSSH: {
										Type:        schema.TypeList,
										Optional:    true,
										MaxItems:    1,
										Description: "",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												attributes.Enabled: {
													Type:        schema.TypeBool,
													Required:    true,
													Description: "", // TODO: add description
												},
											},
										},
									},
								},
							},
						},
						attributes.Conditions: {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "", // TODO: add description
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									attributes.AccessRequest: {
										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												attributes.RequestTypeId: {
													Type:        schema.TypeString,
													Required:    true,
													Description: "", // TODO: add description
												},
												attributes.RequestTypeName: {
													Type:        schema.TypeString,
													Required:    true,
													Description: "", // TODO: add description
												},
											},
										},
									},
									attributes.Gateway: {
										Type:     schema.TypeList,
										Optional: true,
										MaxItems: 1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												attributes.TrafficForwarding: {
													Type:        schema.TypeBool,
													Required:    true,
													Description: "", // TODO: add description
												},
												attributes.SessionRecording: {
													Type:        schema.TypeBool,
													Required:    true,
													Description: "", // TODO: add description
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func resourceSecurityPolicyRead(ctx context.Context, d *schema.ResourceData, m any) diag.Diagnostics {
	var diags diag.Diagnostics
	c := m.(client.OktaPAMClient)
	id := d.Id()
	policy, err := c.GetSecurityPolicy(ctx, id)

	if err != nil {
		return diag.FromErr(err)
	}
	if policy == nil {
		d.SetId("")
		return nil
	}

	resourceMap := policy.ToResourceMap()
	for k, v := range resourceMap {
		if k == attributes.ID {
			d.SetId(v.(string))
		} else {
			if err := d.Set(k, v); err != nil {
				diags = append(diags, diag.FromErr(err)...)
			}
		}
	}

	return diags
}

func resourceSecurityPolicyCreate(ctx context.Context, d *schema.ResourceData, m any) diag.Diagnostics {
	c := m.(client.OktaPAMClient)
	policy, diags := readPolicyFromResourceData(d)
	if diags != nil {
		return diags
	}

	if resultingPolicy, err := c.CreateSecurityPolicy(ctx, policy); err == nil {
		d.SetId(*resultingPolicy.ID)
	} else {
		diags = append(diags, diag.FromErr(err)...)
		return diags
	}

	return resourceSecurityPolicyRead(ctx, d, m)
}

func resourceSecurityPolicyUpdate(ctx context.Context, d *schema.ResourceData, m any) diag.Diagnostics {
	c := m.(client.OktaPAMClient)
	id := d.Id()
	if id == "" {
		return diag.Errorf("could not obtain security policy id from resource")
	}
	policy, diags := readPolicyFromResourceData(d)
	if diags != nil {
		return diags
	}

	if err := c.UpdateSecurityPolicy(ctx, id, policy); err != nil {
		return diag.FromErr(err)
	}

	return resourceSecurityPolicyRead(ctx, d, m)
}

func resourceSecurityPolicyDelete(ctx context.Context, d *schema.ResourceData, m any) diag.Diagnostics {
	var diags diag.Diagnostics
	c := m.(client.OktaPAMClient)
	id := d.Id()
	if err := c.DeleteSecurityPolicy(ctx, id); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	} else {
		d.SetId("")
	}

	return diags
}

func readPolicyFromResourceData(d *schema.ResourceData) (client.SecurityPolicy, diag.Diagnostics) {
	var diags diag.Diagnostics
	var id *string
	idS := d.Id()
	if idS != "" {
		id = &idS
	}
	policy := client.SecurityPolicy{
		ID:     id,
		Name:   GetStringPtrFromResource(attributes.Name, d, false),
		Active: GetBoolPtrFromResource(attributes.Active, d, false),
	}

	if principals, principalsDiags := readPrincipalsFromResourceData(d); principalsDiags != nil {
		diags = append(diags, principalsDiags...)
	} else {
		policy.Principals = principals
	}

	if rules, rulesDiags := readRulesFromResourceData(d, id); rulesDiags != nil {
		diags = append(diags, rulesDiags...)
	} else {
		policy.Rules = rules
	}

	return policy, diags
}

func readRulesFromResourceData(d *schema.ResourceData, securityPolicyId *string) ([]*client.SecurityPolicyRule, diag.Diagnostics) {
	var diags diag.Diagnostics

	rulesAttr := d.Get("rule").([]any)

	rules := make([]*client.SecurityPolicyRule, len(rulesAttr))
	for idx, ruleI := range rulesAttr {
		ruleM := ruleI.(map[string]any)
		var id *string

		if idI, ok := ruleM[attributes.ID]; ok {
			idS := idI.(string)
			if idS != "" {
				id = &idS
			}
		}

		name := ruleM[attributes.Name].(string)
		if len(name) < 1 || len(name) > 256 {
			diags = append(diags, diag.Diagnostic{
				Severity: diag.Error,
				Summary:  fmt.Sprintf("%s for rule must be between 1 and 256 characters, inclusive", attributes.Name),
			})
		}

		rule := &client.SecurityPolicyRule{
			ID:               id,
			SecurityPolicyID: securityPolicyId,
			Name:             &name,
		}

		privilegesI := ruleM[attributes.Privileges].([]any)
		if privileges, privilegesDiag := readPrivileges(privilegesI); privilegesDiag == nil {
			rule.Privileges = privileges
		} else {
			diags = append(diags, privilegesDiag...)
		}

		resourcesI := ruleM[attributes.Resources].([]any)
		if resourceSelector, resourcesDiag := readResourceSelector(resourcesI); resourcesDiag == nil && resourceSelector != nil {
			resourceType := resourceSelector.ResourceSelectorType()
			rule.ResourceType = resourceType
			rule.ResourceSelector = resourceSelector
		} else if resourcesDiag != nil {
			diags = append(diags, resourcesDiag...)
		} else {
			diags = append(diags, diag.Diagnostic{
				Severity: diag.Error,
				Summary:  "no resources defined for rule",
			})
		}

		conditionsI := ruleM[attributes.Conditions].([]any)
		if conditions, conditionsDiag := readConditions(conditionsI); conditionsDiag == nil {
			rule.Conditions = conditions
		} else {
			diags = append(diags, conditionsDiag...)
		}

		rules[idx] = rule
	}

	return rules, diags
}

func readConditions(conditionsAttr []any) ([]*client.SecurityPolicyRuleConditionContainer, diag.Diagnostics) {
	if len(conditionsAttr) == 0 {
		return nil, nil
	}

	var diags diag.Diagnostics
	var conditions []*client.SecurityPolicyRuleConditionContainer
	conditionsM := conditionsAttr[0].(map[string]any)

	if accessRequestAttr, ok := conditionsM[attributes.AccessRequest]; ok {
		accessRequestArr := accessRequestAttr.([]any)
		for _, accessRequestI := range accessRequestArr {
			accessRequestM := accessRequestI.(map[string]any)
			requestTypeId := accessRequestM[attributes.RequestTypeId].(string)
			if len(requestTypeId) < 1 || len(requestTypeId) > 64 {
				diags = append(diags, diag.Diagnostic{
					Severity: diag.Error,
					Summary:  fmt.Sprintf("%s must be between 1 and 64 characters, inclusive", attributes.RequestTypeId),
				})
			}
			requestTypeName := accessRequestM[attributes.RequestTypeName].(string)
			if len(requestTypeName) < 1 || len(requestTypeName) > 1024 {
				diags = append(diags, diag.Diagnostic{
					Severity: diag.Error,
					Summary:  fmt.Sprintf("%s must be between 1 and 1024 characters, inclusive", attributes.RequestTypeName),
				})
			}
			accessRequest := &client.AccessRequestCondition{
				RequestTypeID:   &requestTypeId,
				RequestTypeName: &requestTypeName,
			}

			conditions = append(conditions, &client.SecurityPolicyRuleConditionContainer{
				ConditionType:  accessRequest.ConditionType(),
				ConditionValue: accessRequest,
			})
		}
	}

	if gatewayAttr, ok := conditionsM[attributes.Gateway]; ok {
		gatewayArr := gatewayAttr.([]any)

		for _, gatewayI := range gatewayArr {
			gatewayM := gatewayI.(map[string]any)
			trafficForwarding := gatewayM[attributes.TrafficForwarding].(bool)
			sessionRecording := gatewayM[attributes.SessionRecording].(bool)

			gateway := &client.GatewayCondition{
				TrafficForwarding: &trafficForwarding,
				SessionRecording:  &sessionRecording,
			}

			conditions = append(conditions, &client.SecurityPolicyRuleConditionContainer{
				ConditionType:  gateway.ConditionType(),
				ConditionValue: gateway,
			})
		}
	}

	return conditions, diags
}

func readResourceSelector(resourcesAttr []any) (client.SecurityPolicyRuleResourceSelector, diag.Diagnostics) {
	var diags diag.Diagnostics

	resourcesI := resourcesAttr[0].(map[string]any)

	if serversI, ok := resourcesI[attributes.Servers]; ok {
		subSelectors, diags := readServersSelector(serversI)

		selector := &client.ServerBasedResourceSelector{
			Selectors: subSelectors,
		}

		return selector, diags
	}

	return nil, diags
}

func readServersSelector(serversAttr any) ([]client.ServerBasedResourceSubSelectorContainer, diag.Diagnostics) {
	var diags diag.Diagnostics

	subSelectors := make([]client.ServerBasedResourceSubSelectorContainer, 0, 5)

	serversArr := serversAttr.([]any)
	serversM := serversArr[0].(map[string]any)

	if serversAttr, ok := serversM[attributes.Server]; ok {
		individualServersArr := serversAttr.([]any)
		if selectors, serversDiag := readIndividualServerSubSelectors(individualServersArr); serversDiag == nil {
			for _, selector := range selectors {
				subSelectors = append(subSelectors, client.ServerBasedResourceSubSelectorContainer{
					SelectorType: selector.ServerBasedResourceSubSelectorType(),
					Selector:     selector,
				})
			}
		} else {
			diags = append(diags, serversDiag...)
		}
	}

	if serverAccountsAttr, ok := serversM[attributes.ServerAccount]; ok {
		individualServerAccountsArr := serverAccountsAttr.([]any)
		if selectors, serversDiag := readIndividualServerAccountSubSelectors(individualServerAccountsArr); serversDiag == nil {
			for _, selector := range selectors {
				subSelectors = append(subSelectors, client.ServerBasedResourceSubSelectorContainer{
					SelectorType: selector.ServerBasedResourceSubSelectorType(),
					Selector:     selector,
				})
			}
		} else {
			diags = append(diags, serversDiag...)
		}
	}

	if labelSelectorsAttr, ok := serversM[attributes.LabelSelectors]; ok {
		labelSelectorsArr := labelSelectorsAttr.([]any)
		if selectors, labelSelectorsDiag := readServerLabelBasedSubSelectors(labelSelectorsArr); labelSelectorsDiag == nil {
			for _, selector := range selectors {
				subSelectors = append(subSelectors, client.ServerBasedResourceSubSelectorContainer{
					SelectorType: selector.ServerBasedResourceSubSelectorType(),
					Selector:     selector,
				})
			}
		} else {
			diags = append(diags, labelSelectorsDiag...)
		}
	}

	return subSelectors, diags
}

func readServerLabelBasedSubSelectors(labelSelectorsArr []any) ([]*client.ServerLabelBasedSubSelector, diag.Diagnostics) {
	var diags diag.Diagnostics

	subSelectors := make([]*client.ServerLabelBasedSubSelector, len(labelSelectorsArr))

	for idx, labelSelectorsI := range labelSelectorsArr {
		subSelector := &client.ServerLabelBasedSubSelector{}
		labelSelectorsM := labelSelectorsI.(map[string]any)

		serverLabelsI := labelSelectorsM[attributes.ServerLabels]
		serverLabelsM := serverLabelsI.(map[string]any)
		serverLabels := make(map[string]string, len(serverLabelsM))
		for k, v := range serverLabelsM {
			s := v.(string)
			if strings.ContainsAny(k, "=,") {
				diags = append(diags, diag.Diagnostic{
					Severity: diag.Error,
					Summary:  fmt.Sprintf("%s key cannot contain a ':', '=', ',' character: %s", attributes.ServerLabels, s),
				})
			}

			if strings.ContainsAny(s, ":=,") {
				diags = append(diags, diag.Diagnostic{
					Severity: diag.Error,
					Summary:  fmt.Sprintf("%s value cannot contain a ':', '=', ',' character: %s", attributes.ServerLabels, s),
				})
			}
			serverLabels[k] = s
		}
		subSelector.ServerSelector = &client.ServerLabelServerSelector{
			Labels: serverLabels,
		}

		usernamesI := labelSelectorsM[attributes.Usernames]
		usernamesArr := usernamesI.([]any)

		var accountSelector client.AccountSelector
		if len(usernamesArr) == 0 {
			accountSelector = &client.NoneAccountSelector{}
		} else {
			usernames := make([]string, len(usernamesArr))
			for uIdx, usernameI := range usernamesArr {
				usernames[uIdx] = usernameI.(string)
			}
			accountSelector = &client.UsernameAccountSelector{Usernames: usernames}
		}
		subSelector.AccountSelector = accountSelector
		subSelector.AccountSelectorType = accountSelector.AccountSelectorType()

		subSelectors[idx] = subSelector
	}

	return subSelectors, diags
}

func readIndividualServerAccountSubSelectors(serverAccountsArr []any) ([]*client.IndividualServerAccountSubSelector, diag.Diagnostics) {
	var diags diag.Diagnostics

	subSelectors := make([]*client.IndividualServerAccountSubSelector, len(serverAccountsArr))

	for idx, serverI := range serverAccountsArr {
		serverM := serverI.(map[string]any)
		serverId := serverM[attributes.ServerId].(string)
		username := serverM[attributes.Username].(string)
		if MatchesUUID(serverId) {
			subSelectors[idx] = &client.IndividualServerAccountSubSelector{
				ServerId: ConvertToNamedObject(serverId, client.ServerNamedObjectType),
				Username: &username,
			}
		} else {
			diags = append(diags, diag.Diagnostic{
				Severity: diag.Error,
				Summary:  fmt.Sprintf("server_id value must be a UUID: %s", serverId),
			})
		}
	}

	return subSelectors, diags
}

func readIndividualServerSubSelectors(serversArr []any) ([]*client.IndividualServerSubSelector, diag.Diagnostics) {
	var diags diag.Diagnostics

	subSelectors := make([]*client.IndividualServerSubSelector, len(serversArr))

	for idx, serverI := range serversArr {
		serverM := serverI.(map[string]any)
		serverIdI := serverM[attributes.ServerId]
		serverId := serverIdI.(string)
		if MatchesUUID(serverId) {
			subSelectors[idx] = &client.IndividualServerSubSelector{
				ServerId: ConvertToNamedObject(serverId, client.ServerNamedObjectType),
			}
		} else {
			diags = append(diags, diag.Diagnostic{
				Severity: diag.Error,
				Summary:  fmt.Sprintf("server_id value must be a UUID: %s", serverId),
			})
		}
	}

	return subSelectors, diags
}

func readPrivileges(privilegesAttr []any) ([]*client.SecurityPolicyRulePrivilegeContainer, diag.Diagnostics) {
	var diags diag.Diagnostics

	privileges := make([]*client.SecurityPolicyRulePrivilegeContainer, 0, 4)
	privilegesM := privilegesAttr[0].(map[string]any)

	if passwordCheckoutRDPI, ok := privilegesM[attributes.PasswordCheckoutRDP]; ok {
		if enabled, hasValue := readPrivilegeEnabled(passwordCheckoutRDPI); hasValue {
			privileges = append(privileges, &client.SecurityPolicyRulePrivilegeContainer{
				PrivilegeType: client.PasswordCheckoutRDPPrivilegeType,
				PrivilegeValue: &client.PasswordCheckoutRDPPrivilege{
					Enabled: &enabled,
				},
			})
		}
	}

	if passwordCheckoutSSHI, ok := privilegesM[attributes.PasswordCheckoutSSH]; ok {
		if enabled, hasValue := readPrivilegeEnabled(passwordCheckoutSSHI); hasValue {
			privileges = append(privileges, &client.SecurityPolicyRulePrivilegeContainer{
				PrivilegeType: client.PasswordCheckoutSSHPrivilegeType,
				PrivilegeValue: &client.PasswordCheckoutSSHPrivilege{
					Enabled: &enabled,
				},
			})
		}
	}

	if principalAccountRDPI, ok := privilegesM[attributes.PrincipalAccountRDP]; ok {
		if enabled, hasValue := readPrivilegeEnabled(principalAccountRDPI); hasValue {
			privileges = append(privileges, &client.SecurityPolicyRulePrivilegeContainer{
				PrivilegeType: client.PrincipalAccountRDPPrivilegeType,
				PrivilegeValue: &client.PrincipalAccountRDPPrivilege{
					Enabled: &enabled,
				},
			})
		}
	}

	if principalAccountSSHI, ok := privilegesM[attributes.PrincipalAccountSSH]; ok {
		if enabled, hasValue := readPrivilegeEnabled(principalAccountSSHI); hasValue {
			privileges = append(privileges, &client.SecurityPolicyRulePrivilegeContainer{
				PrivilegeType: client.PrincipalAccountSSHPrivilegeType,
				PrivilegeValue: &client.PrincipalAccountSSHPrivilege{
					Enabled: &enabled,
				},
			})
		}
	}

	return privileges, diags
}

func readPrivilegeEnabled(privilege any) (bool, bool) {
	privilegeArr := privilege.([]any)

	if len(privilegeArr) == 0 {
		return false, false
	}

	privilegeM := privilegeArr[0].(map[string]any)

	if enabledI, ok := privilegeM[attributes.Enabled]; ok {
		return enabledI.(bool), true
	}

	return false, true
}

func readPrincipalsFromResourceData(d *schema.ResourceData) (*client.SecurityPolicyPrincipals, diag.Diagnostics) {
	var diags diag.Diagnostics
	principals := &client.SecurityPolicyPrincipals{}

	principalsAttr := d.Get("principals").([]any)
	if len(principalsAttr) != 1 {
		diags = append(diags, diag.Diagnostic{
			Severity: diag.Error,
			Summary:  "must have exactly one principal block",
		})
	}

	principalMap := principalsAttr[0].(map[string]any)
	if usersAttr, ok := principalMap[attributes.Users]; ok {
		users, usersDiag := GetUUIDSlice(usersAttr, attributes.Users)
		if usersDiag != nil {
			diags = append(diags, usersDiag...)
		} else {
			principals.Users = ConvertToNamedObjectSlice(users, client.UserNamedObjectType)
		}
	}
	if usersAttr, ok := principalMap[attributes.Groups]; ok {
		groups, groupsDiag := GetUUIDSlice(usersAttr, attributes.Groups)
		if groupsDiag != nil {
			diags = append(diags, groupsDiag...)
		} else {
			principals.UserGroups = ConvertToNamedObjectSlice(groups, client.UserGroupNamedObjectType)
		}
	}

	if diags == nil && len(principals.Users) == 0 && len(principals.UserGroups) == 0 {
		diags = append(diags, diag.Diagnostic{
			Severity: diag.Error,
			Summary:  "must include at least one user or group in principals",
		})
	}

	return principals, diags
}
