package oktapam

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/okta/terraform-provider-oktapam/oktapam/client"
	"github.com/okta/terraform-provider-oktapam/oktapam/constants/attributes"
	"github.com/okta/terraform-provider-oktapam/oktapam/constants/descriptions"
)

func resourceSecurityPolicy() *schema.Resource {
	return &schema.Resource{
		Description:   descriptions.ResourceSecurityPolicy,
		CreateContext: resourceSecurityPolicyCreate,
		ReadContext:   resourceSecurityPolicyRead,
		DeleteContext: resourceSecurityPolicyDelete,
		UpdateContext: resourceSecurityPolicyUpdate,
		Schema: map[string]*schema.Schema{
			attributes.ID: {
				Type:     schema.TypeString,
				Computed: true,
				// Description is autogenerated
			},
			attributes.Name: {
				Type:             schema.TypeString,
				Required:         true,
				Description:      descriptions.Name,
				ValidateDiagFunc: validation.ToDiagFunc(validation.StringLenBetween(1, 255)),
			},
			attributes.Description: {
				Type:        schema.TypeString,
				Optional:    true,
				Description: descriptions.Description,
			},
			attributes.Active: {
				Type:        schema.TypeBool,
				Required:    true,
				Description: descriptions.SecurityPolicyActive,
			},
			attributes.ResourceGroup: {
				Type:        schema.TypeString,
				Optional:    true,
				Description: descriptions.SecurityPolicyResouceGroup,
			},
			attributes.Principals: {
				Type:        schema.TypeList,
				Required:    true,
				MinItems:    1,
				MaxItems:    1,
				Description: descriptions.SecurityPolicyPrincipals,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						attributes.Groups: {
							Type: schema.TypeSet,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Optional:    true,
							Description: descriptions.PrincipalGroupIDs,
						},
					},
				},
			},
			attributes.Rule: {
				Type:        schema.TypeSet,
				Required:    true,
				MinItems:    1,
				MaxItems:    20,
				Description: descriptions.SecurityPolicyRule,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						attributes.Name: {
							Type:        schema.TypeString,
							Required:    true,
							Description: descriptions.Name,
						},
						attributes.Resources: {
							Type:        schema.TypeList,
							Required:    true,
							MinItems:    1,
							MaxItems:    1,
							Description: descriptions.SecurityPolicyResources,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									attributes.Secrets: {
										Type:        schema.TypeList,
										Optional:    true,
										MinItems:    1,
										MaxItems:    1,
										Description: descriptions.SecurityPolicySecrets,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												attributes.Secret: {
													Type:        schema.TypeList,
													Optional:    true,
													MinItems:    0,
													MaxItems:    1,
													Description: descriptions.SecurityPolicySecret,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															attributes.SecretID: {
																Type:        schema.TypeString,
																Required:    true,
																Description: descriptions.SecretID,
															},
														},
													},
												},
												attributes.SecretFolder: {
													Type:        schema.TypeList,
													Optional:    true,
													MinItems:    0,
													MaxItems:    1,
													Description: descriptions.SecurityPolicySecretFolder,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															attributes.SecretFolderID: {
																Type:        schema.TypeString,
																Required:    true,
																Description: descriptions.SecretFolderID,
															},
														},
													},
												},
											},
										},
									},
									attributes.Servers: {
										Type:        schema.TypeList,
										Optional:    true,
										MinItems:    1,
										MaxItems:    1,
										Description: descriptions.SecurityPolicyServers,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												attributes.Server: {
													Type:        schema.TypeList,
													Optional:    true,
													Description: descriptions.SecurityPolicyServer,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															attributes.ServerID: {
																Type:        schema.TypeString,
																Required:    true,
																Description: descriptions.ServerID,
															},
														},
													},
												},
												attributes.ServerAccount: {
													Type:        schema.TypeList,
													Optional:    true,
													Description: descriptions.SecurityPolicyServerAccount,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															attributes.ServerID: {
																Type:        schema.TypeString,
																Required:    true,
																Description: descriptions.ServerID,
															},
															attributes.Account: {
																Type:        schema.TypeString,
																Required:    true,
																Description: descriptions.LocalAccount,
															},
														},
													},
												},
												attributes.LabelSelectors: {
													Type:        schema.TypeList,
													Optional:    true,
													MaxItems:    1,
													Description: descriptions.SecurityPolicyLabelSelectors,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															attributes.ServerLabels: {
																Type:        schema.TypeMap,
																Required:    true,
																Description: descriptions.SecurityPolicyServerLabels,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
															attributes.Accounts: {
																Type:        schema.TypeList,
																Optional:    true,
																Description: descriptions.LocalAccounts,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						attributes.Privileges: {
							Type:        schema.TypeList,
							Required:    true,
							MinItems:    1,
							MaxItems:    1,
							Description: descriptions.Privileges,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									attributes.Secret: {
										Type:        schema.TypeList,
										Optional:    true,
										MaxItems:    1,
										Description: descriptions.PrivilegeSecret,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												attributes.List: {
													Type:        schema.TypeBool,
													Required:    true,
													Description: descriptions.PrivilegeSecretList,
												},
												attributes.FolderCreate: {
													Type:        schema.TypeBool,
													Required:    true,
													Description: descriptions.PrivilegeSecretFolderCreate,
												},
												attributes.FolderDelete: {
													Type:        schema.TypeBool,
													Required:    true,
													Description: descriptions.PrivilegeSecretFolderDelete,
												},
												attributes.FolderUpdate: {
													Type:        schema.TypeBool,
													Required:    true,
													Description: descriptions.PrivilegeSecretFolderUpdate,
												},
												attributes.SecretCreate: {
													Type:        schema.TypeBool,
													Required:    true,
													Description: descriptions.PrivilegeSecretCreate,
												},
												attributes.SecretDelete: {
													Type:        schema.TypeBool,
													Required:    true,
													Description: descriptions.PrivilegeSecretDelete,
												},
												attributes.SecretReveal: {
													Type:        schema.TypeBool,
													Required:    true,
													Description: descriptions.PrivilegeSecretReveal,
												},
												attributes.SecretUpdate: {
													Type:        schema.TypeBool,
													Required:    true,
													Description: descriptions.PrivilegeSecretUpdate,
												},
											},
										},
									},
									attributes.PasswordCheckoutRDP: {
										Type:        schema.TypeList,
										Optional:    true,
										MaxItems:    1,
										Description: descriptions.PrivilegePasswordCheckoutRDP,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												attributes.Enabled: {
													Type:        schema.TypeBool,
													Required:    true,
													Description: descriptions.PrivilegeEnabled,
												},
											},
										},
									},
									attributes.PasswordCheckoutSSH: {
										Type:        schema.TypeList,
										Optional:    true,
										MaxItems:    1,
										Description: descriptions.PrivilegePasswordCheckoutSSH,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												attributes.Enabled: {
													Type:        schema.TypeBool,
													Required:    true,
													Description: descriptions.PrivilegeEnabled,
												},
											},
										},
									},
									attributes.PrincipalAccountRDP: {
										Type:        schema.TypeList,
										Optional:    true,
										MaxItems:    1,
										Description: descriptions.PrivilegePrincipalAccountRDP,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												attributes.Enabled: {
													Type:        schema.TypeBool,
													Required:    true,
													Description: descriptions.PrivilegeEnabled,
												},
												attributes.AdminLevelPermissions: {
													Type:        schema.TypeBool,
													Optional:    true,
													Default:     false,
													Description: descriptions.AdminLevelPermissions,
												},
											},
										},
									},
									attributes.PrincipalAccountSSH: {
										Type:        schema.TypeList,
										Optional:    true,
										MaxItems:    1,
										Description: descriptions.PrivilegePrincipalAccountSSH,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												attributes.Enabled: {
													Type:        schema.TypeBool,
													Required:    true,
													Description: descriptions.PrivilegeEnabled,
												},
												attributes.AdminLevelPermissions: {
													Type:        schema.TypeBool,
													Optional:    true,
													Computed:    true,
													Description: descriptions.AdminLevelPermissions,
												},
											},
										},
									},
								},
							},
						},
						attributes.Conditions: {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: descriptions.Conditions,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									attributes.MFA: {
										Type:        schema.TypeList,
										Optional:    true,
										Description: descriptions.ConditionMFA,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												attributes.ReAuthFrequencyInSeconds: {
													Type:        schema.TypeInt,
													Required:    true,
													Description: descriptions.MFAReAuthFrequencyInSeconds,
												},
												attributes.ACRValues: {
													Type:        schema.TypeString,
													Required:    true,
													Description: descriptions.MFAACRValues,
												},
											},
										},
									},
									attributes.AccessRequest: {
										Type:        schema.TypeList,
										Optional:    true,
										Description: descriptions.ConditionAccessRequest,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												attributes.RequestTypeId: {
													Type:        schema.TypeString,
													Required:    true,
													Description: descriptions.ConditionAccessRequestRequestTypeID,
												},
												attributes.RequestTypeName: {
													Type:        schema.TypeString,
													Required:    true,
													Description: descriptions.ConditionAccessRequestRequestTypeName,
												},
												attributes.ExpiresAfterSeconds: {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: descriptions.ConditionAccessRequestExpiresAfterSeconds,
												},
											},
										},
									},
									attributes.Gateway: {
										Type:        schema.TypeList,
										Optional:    true,
										MaxItems:    1,
										Description: descriptions.ConditionGateway,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												attributes.TrafficForwarding: {
													Type:        schema.TypeBool,
													Required:    true,
													Description: descriptions.ConditionTrafficForwarding,
												},
												attributes.SessionRecording: {
													Type:        schema.TypeBool,
													Required:    true,
													Description: descriptions.ConditionSessionRecording,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
	}
}

func resourceSecurityPolicyRead(ctx context.Context, d *schema.ResourceData, m any) diag.Diagnostics {
	var diags diag.Diagnostics
	c := getLocalClientFromMetadata(m)
	id := d.Id()
	policy, err := c.GetSecurityPolicy(ctx, id)

	if err != nil {
		return diag.FromErr(err)
	}
	if policy == nil {
		d.SetId("")
		return nil
	}

	resourceMap := policy.ToResourceMap()
	for k, v := range resourceMap {
		if k == attributes.ID {
			d.SetId(v.(string))
		} else {
			if err := d.Set(k, v); err != nil {
				diags = append(diags, diag.FromErr(err)...)
			}
		}
	}

	return diags
}

func resourceSecurityPolicyCreate(ctx context.Context, d *schema.ResourceData, m any) diag.Diagnostics {
	c := getLocalClientFromMetadata(m)
	policy, diags := readPolicyFromResourceData(d)
	if diags != nil {
		return diags
	}

	if resultingPolicy, err := c.CreateSecurityPolicy(ctx, policy); err == nil {
		d.SetId(*resultingPolicy.ID)
	} else {
		diags = append(diags, diag.FromErr(err)...)
		return diags
	}

	return resourceSecurityPolicyRead(ctx, d, m)
}

func resourceSecurityPolicyUpdate(ctx context.Context, d *schema.ResourceData, m any) diag.Diagnostics {
	c := getLocalClientFromMetadata(m)
	id := d.Id()
	if id == "" {
		return diag.Errorf("could not obtain security policy id from resource")
	}
	policy, diags := readPolicyFromResourceData(d)
	if diags != nil {
		return diags
	}

	if err := c.UpdateSecurityPolicy(ctx, id, policy); err != nil {
		return diag.FromErr(err)
	}

	return resourceSecurityPolicyRead(ctx, d, m)
}

func resourceSecurityPolicyDelete(ctx context.Context, d *schema.ResourceData, m any) diag.Diagnostics {
	var diags diag.Diagnostics
	c := getLocalClientFromMetadata(m)
	id := d.Id()
	if err := c.DeleteSecurityPolicy(ctx, id); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	} else {
		d.SetId("")
	}

	return diags
}

func readPolicyFromResourceData(d *schema.ResourceData) (client.SecurityPolicy, diag.Diagnostics) {
	var diags diag.Diagnostics
	var id *string
	idS := d.Id()
	if idS != "" {
		id = &idS
	}

	policy := client.SecurityPolicy{
		ID:          id,
		Name:        GetStringPtrFromResource(attributes.Name, d, false),
		Active:      GetBoolPtrFromResource(attributes.Active, d, false),
		Description: GetStringPtrFromResource(attributes.Description, d, false),
	}

	if resourceGroupID := GetStringPtrFromResource(attributes.ResourceGroup, d, false); resourceGroupID != nil {
		if MatchesUUID(*resourceGroupID) {
			rg := ConvertToNamedObject(*resourceGroupID, client.ResourceGroupNamedObjectType)
			policy.ResourceGroup = &rg
		} else {
			diags = append(diags, diag.Diagnostic{
				Severity: diag.Error,
				Summary:  fmt.Sprintf("%s value must be a UUID: %s", attributes.ResourceGroup, *resourceGroupID),
			})
		}
	}

	if principals, principalsDiags := readPrincipalsFromResourceData(d); principalsDiags != nil {
		diags = append(diags, principalsDiags...)
	} else {
		policy.Principals = principals
	}

	if rules, rulesDiags := readRulesFromResourceData(d, id); rulesDiags != nil {
		diags = append(diags, rulesDiags...)
	} else {
		policy.Rules = rules
	}

	return policy, diags
}

func readRulesFromResourceData(d *schema.ResourceData, securityPolicyId *string) ([]*client.SecurityPolicyRule, diag.Diagnostics) {
	var diags diag.Diagnostics

	rulesSet := d.Get("rule").(*schema.Set)
	rulesAttr := rulesSet.List()

	rules := make([]*client.SecurityPolicyRule, 0, len(rulesAttr))
	for _, ruleI := range rulesAttr {
		ruleM := ruleI.(map[string]any)
		var id *string

		if idI, ok := ruleM[attributes.ID]; ok {
			idS := idI.(string)
			if idS != "" {
				id = &idS
			}
		}

		name := ruleM[attributes.Name].(string)

		if len(name) == 0 &&
			len(ruleM[attributes.Privileges].([]any)) == 0 &&
			len(ruleM[attributes.Resources].([]any)) == 0 &&
			len(ruleM[attributes.Conditions].([]any)) == 0 {
			// due to the bug of https://github.com/hashicorp/terraform-plugin-sdk/pull/1042
			// when using a TypeSet, we get an empty map of values during the Update phase.
			// we should ignore this value
			continue
		}

		if len(name) < 1 || len(name) > 256 {
			diags = append(diags, diag.Diagnostic{
				Severity: diag.Error,
				Summary:  fmt.Sprintf("%s for rule must be between 1 and 256 characters, inclusive", attributes.Name),
			})
		}

		rule := &client.SecurityPolicyRule{
			ID:               id,
			SecurityPolicyID: securityPolicyId,
			Name:             &name,
		}

		privilegesI := ruleM[attributes.Privileges].([]any)
		if privileges, privilegesDiag := readPrivileges(privilegesI); privilegesDiag == nil {
			rule.Privileges = privileges
		} else {
			diags = append(diags, privilegesDiag...)
		}

		resourcesI := ruleM[attributes.Resources].([]any)
		if resourceSelector, resourcesDiag := readResourceSelector(resourcesI); resourcesDiag == nil && resourceSelector != nil {
			resourceType := resourceSelector.ResourceSelectorType()
			rule.ResourceType = resourceType
			rule.ResourceSelector = resourceSelector
		} else if resourcesDiag != nil {
			diags = append(diags, resourcesDiag...)
		} else {
			diags = append(diags, diag.Diagnostic{
				Severity: diag.Error,
				Summary:  "no resources defined for rule",
			})
		}

		conditionsI := ruleM[attributes.Conditions].([]any)
		if conditions, conditionsDiag := readConditions(conditionsI); conditionsDiag == nil {
			rule.Conditions = conditions
		} else {
			diags = append(diags, conditionsDiag...)
		}

		rules = append(rules, rule)

		if validation := validateRule(rule); validation != nil {
			diags = append(diags, validation...)
		}
	}

	return rules, diags
}

func validateRule(rule *client.SecurityPolicyRule) diag.Diagnostics {
	var diags diag.Diagnostics

	for _, priv := range rule.Privileges {
		if !priv.PrivilegeValue.ValidForResourceType(rule.ResourceType) {
			resourceTypeAttribute := resourceTypeToAttribute(rule.ResourceType)
			privilegeTypeAttribute := privilegeTypeToAttribute(priv.PrivilegeType)

			diags = append(diags, diag.Diagnostic{
				Severity: diag.Error,
				Summary:  fmt.Sprintf("cannot use privilege of type %s with resource of type %s", privilegeTypeAttribute, resourceTypeAttribute),
			})
		}
	}

	for _, cond := range rule.Conditions {
		if !cond.ConditionValue.ValidForResourceType(rule.ResourceType) {
			resourceTypeAttribute := resourceTypeToAttribute(rule.ResourceType)
			conditionTypeAttribute := conditionTypeToAttribute(cond.ConditionType)

			diags = append(diags, diag.Diagnostic{
				Severity: diag.Error,
				Summary:  fmt.Sprintf("cannot use condition of type %s with resource of type %s", conditionTypeAttribute, resourceTypeAttribute),
			})
		}
	}

	return diags
}

func resourceTypeToAttribute(resourceSelectorType client.ResourceSelectorType) string {
	switch resourceSelectorType {
	case client.SecretBasedResourceSelectorType:
		return attributes.Secrets
	case client.ServerBasedResourceSelectorType:
		return attributes.Servers
	default:
		return string(resourceSelectorType)
	}
}

func privilegeTypeToAttribute(privilegeType client.PrivilegeType) string {
	switch privilegeType {
	case client.PasswordCheckoutRDPPrivilegeType:
		return attributes.PasswordCheckoutRDP
	case client.PrincipalAccountRDPPrivilegeType:
		return attributes.PrincipalAccountRDP
	case client.PasswordCheckoutSSHPrivilegeType:
		return attributes.PasswordCheckoutSSH
	case client.PrincipalAccountSSHPrivilegeType:
		return attributes.PrincipalAccountSSH
	case client.SecretPrivilegeType:
		return attributes.Secret
	default:
		return string(privilegeType)
	}
}

func conditionTypeToAttribute(conditionType client.ConditionType) string {
	switch conditionType {
	case client.AccessRequestConditionType:
		return attributes.AccessRequest
	case client.GatewayConditionType:
		return attributes.Gateway
	case client.MFAConditionType:
		return attributes.MFA
	default:
		return string(conditionType)
	}
}

func readConditions(conditionsAttr []any) ([]*client.SecurityPolicyRuleConditionContainer, diag.Diagnostics) {
	if len(conditionsAttr) == 0 {
		return nil, nil
	}

	if conditionsAttr[0] == nil {
		return nil, diag.Diagnostics{diag.Diagnostic{
			Severity: diag.Error,
			Summary:  "conditions block should not be empty",
		}}
	}

	var diags diag.Diagnostics
	var conditions []*client.SecurityPolicyRuleConditionContainer
	conditionsM := conditionsAttr[0].(map[string]any)

	if accessRequestAttr, ok := conditionsM[attributes.AccessRequest]; ok {
		accessRequestArr := accessRequestAttr.([]any)
		for _, accessRequestI := range accessRequestArr {
			accessRequestM := accessRequestI.(map[string]any)
			requestTypeId := accessRequestM[attributes.RequestTypeId].(string)
			if len(requestTypeId) < 1 || len(requestTypeId) > 64 {
				diags = append(diags, diag.Diagnostic{
					Severity: diag.Error,
					Summary:  fmt.Sprintf("%s must be between 1 and 64 characters, inclusive", attributes.RequestTypeId),
				})
			}
			requestTypeName := accessRequestM[attributes.RequestTypeName].(string)
			if len(requestTypeName) < 1 || len(requestTypeName) > 1024 {
				diags = append(diags, diag.Diagnostic{
					Severity: diag.Error,
					Summary:  fmt.Sprintf("%s must be between 1 and 1024 characters, inclusive", attributes.RequestTypeName),
				})
			}

			var expiresAfterSeconds *int
			if expiresAfterSecondsAttr, ok := accessRequestM[attributes.ExpiresAfterSeconds]; ok {
				expiresAfterSecondsI := expiresAfterSecondsAttr.(int)
				expiresAfterSeconds = &expiresAfterSecondsI
			}

			accessRequest := &client.AccessRequestCondition{
				RequestTypeID:       &requestTypeId,
				RequestTypeName:     &requestTypeName,
				ExpiresAfterSeconds: expiresAfterSeconds,
			}

			conditions = append(conditions, &client.SecurityPolicyRuleConditionContainer{
				ConditionType:  accessRequest.ConditionType(),
				ConditionValue: accessRequest,
			})
		}
	}

	if gatewayAttr, ok := conditionsM[attributes.Gateway]; ok {
		gatewayArr := gatewayAttr.([]any)

		for _, gatewayI := range gatewayArr {
			gatewayM := gatewayI.(map[string]any)
			trafficForwarding := gatewayM[attributes.TrafficForwarding].(bool)
			sessionRecording := gatewayM[attributes.SessionRecording].(bool)

			gateway := &client.GatewayCondition{
				TrafficForwarding: &trafficForwarding,
				SessionRecording:  &sessionRecording,
			}

			conditions = append(conditions, &client.SecurityPolicyRuleConditionContainer{
				ConditionType:  gateway.ConditionType(),
				ConditionValue: gateway,
			})
		}
	}

	if mfaAttr, ok := conditionsM[attributes.MFA]; ok {
		mfaArr := mfaAttr.([]any)

		for _, mfaI := range mfaArr {
			mfaM := mfaI.(map[string]any)

			reauthFrequency := mfaM[attributes.ReAuthFrequencyInSeconds].(int)
			acrValues := mfaM[attributes.ACRValues].(string)

			mfa := &client.MFACondition{
				ReAuthFrequencyInSeconds: &reauthFrequency,
				ACRValues:                &acrValues,
			}

			conditions = append(conditions, &client.SecurityPolicyRuleConditionContainer{
				ConditionType:  mfa.ConditionType(),
				ConditionValue: mfa,
			})
		}
	}

	return conditions, diags
}

func readResourceSelector(resourcesAttr []any) (client.SecurityPolicyRuleResourceSelector, diag.Diagnostics) {
	var diags diag.Diagnostics

	if len(resourcesAttr) == 0 {
		diags = append(diags, diag.Diagnostic{
			Severity: diag.Error,
			Summary:  "must supply at least one resource selector",
		})
		return nil, diags
	}

	resourcesI := resourcesAttr[0].(map[string]any)
	var selector client.SecurityPolicyRuleResourceSelector

	if serversI, ok := resourcesI[attributes.Servers]; ok {
		if subSelectors, d := readServersSelector(serversI); d != nil {
			diags = append(diags, d...)
		} else if subSelectors != nil {
			selector = &client.ServerBasedResourceSelector{
				Selectors: subSelectors,
			}
		}
	}

	if secretsI, ok := resourcesI[attributes.Secrets]; ok {
		if subSelectors, d := readSecretsSelector(secretsI); d != nil {
			diags = append(diags, d...)
		} else if subSelectors != nil {
			if selector != nil {
				diags = append(diags, diag.Diagnostic{
					Severity: diag.Error,
					Summary:  fmt.Sprintf("cannot supply both %s and %s resources", attributes.Servers, attributes.Secrets),
				})
			} else {
				selector = &client.SecretBasedResourceSelector{
					Selectors: subSelectors,
				}
			}
		}
	}

	if selector == nil {
		diags = append(diags, diag.Diagnostic{
			Severity: diag.Error,
			Summary:  fmt.Sprintf("must supply either %s or %s values under %s", attributes.Servers, attributes.Secrets, attributes.Resources),
		})
	}

	return selector, diags
}

func readSecretsSelector(secretsAttr any) ([]client.SecretBasedResourceSubSelectorContainer, diag.Diagnostics) {
	var diags diag.Diagnostics

	subSelectors := make([]client.SecretBasedResourceSubSelectorContainer, 0, 1)

	secretsArr := secretsAttr.([]any)
	if len(secretsArr) == 0 || secretsArr[0] == nil {
		// we don't have any secrets defined
		return nil, nil
	}

	secretsM := secretsArr[0].(map[string]any)

	if secretAttr, ok := secretsM[attributes.Secret]; ok {
		secretArr := secretAttr.([]any)
		if selectors, secretDiag := readSecretSubSelectors(secretArr); secretDiag == nil {
			for _, selector := range selectors {
				subSelectors = append(subSelectors, client.SecretBasedResourceSubSelectorContainer{
					SelectorType: selector.SecretBasedResourceSubSelectorType(),
					Selector:     selector,
				})
			}
		} else {
			diags = append(diags, secretDiag...)
		}
	}

	if secretFolderAttr, ok := secretsM[attributes.SecretFolder]; ok {
		secretFolderArr := secretFolderAttr.([]any)
		if selectors, secretFolderDiag := readSecretFolderSubSelectors(secretFolderArr); secretFolderDiag == nil {
			for _, selector := range selectors {
				if len(subSelectors) == 0 {
					subSelectors = append(subSelectors, client.SecretBasedResourceSubSelectorContainer{
						SelectorType: selector.SecretBasedResourceSubSelectorType(),
						Selector:     selector,
					})
				} else {
					diags = append(diags, diag.Diagnostic{
						Severity: diag.Error,
						Summary:  fmt.Sprintf("only a single %s or %s resource is allowed as a target within a rule", attributes.Secret, attributes.SecretFolder),
					})
				}
			}
		} else {
			diags = append(diags, secretFolderDiag...)
		}
	}

	return subSelectors, diags
}

func readSecretSubSelectors(secretArr []any) ([]*client.SecretSubSelector, diag.Diagnostics) {
	var diags diag.Diagnostics

	subSelectors := make([]*client.SecretSubSelector, len(secretArr))

	for idx, secretI := range secretArr {
		secretM := secretI.(map[string]any)
		secretIdI := secretM[attributes.SecretID]
		secretId := secretIdI.(string)
		if MatchesUUID(secretId) {
			subSelectors[idx] = &client.SecretSubSelector{
				SecretID: ConvertToNamedObject(secretId, client.SecretNamedObjectType),
			}
		} else {
			diags = append(diags, diag.Diagnostic{
				Severity: diag.Error,
				Summary:  fmt.Sprintf("%s value must be a UUID: %s", attributes.SecretID, secretId),
			})
		}
	}

	return subSelectors, diags
}

func readSecretFolderSubSelectors(secretFolderArr []any) ([]*client.SecretFolderSubSelector, diag.Diagnostics) {
	var diags diag.Diagnostics

	subSelectors := make([]*client.SecretFolderSubSelector, len(secretFolderArr))

	for idx, secretFolderI := range secretFolderArr {
		secretFolderM := secretFolderI.(map[string]any)
		secretFolderIdI := secretFolderM[attributes.SecretFolderID]
		secretFolderId := secretFolderIdI.(string)
		if MatchesUUID(secretFolderId) {
			subSelectors[idx] = &client.SecretFolderSubSelector{
				SecretFolderID: ConvertToNamedObject(secretFolderId, client.SecretFolderNamedObjectType),
			}
		} else {
			diags = append(diags, diag.Diagnostic{
				Severity: diag.Error,
				Summary:  fmt.Sprintf("%s value must be a UUID: %s", attributes.SecretFolderID, secretFolderId),
			})
		}
	}

	return subSelectors, diags
}

func readServersSelector(serversAttr any) ([]client.ServerBasedResourceSubSelectorContainer, diag.Diagnostics) {
	var diags diag.Diagnostics

	subSelectors := make([]client.ServerBasedResourceSubSelectorContainer, 0, 5)

	serversArr := serversAttr.([]any)
	if len(serversArr) == 0 || serversArr[0] == nil {
		// we don't have any servers defined
		return nil, nil
	}
	serversM := serversArr[0].(map[string]any)

	if serversAttr, ok := serversM[attributes.Server]; ok {
		individualServersArr := serversAttr.([]any)
		if selectors, serversDiag := readIndividualServerSubSelectors(individualServersArr); serversDiag == nil {
			for _, selector := range selectors {
				subSelectors = append(subSelectors, client.ServerBasedResourceSubSelectorContainer{
					SelectorType: selector.ServerBasedResourceSubSelectorType(),
					Selector:     selector,
				})
			}
		} else {
			diags = append(diags, serversDiag...)
		}
	}

	if serverAccountsAttr, ok := serversM[attributes.ServerAccount]; ok {
		individualServerAccountsArr := serverAccountsAttr.([]any)
		if selectors, serversDiag := readIndividualServerAccountSubSelectors(individualServerAccountsArr); serversDiag == nil {
			for _, selector := range selectors {
				subSelectors = append(subSelectors, client.ServerBasedResourceSubSelectorContainer{
					SelectorType: selector.ServerBasedResourceSubSelectorType(),
					Selector:     selector,
				})
			}
		} else {
			diags = append(diags, serversDiag...)
		}
	}

	if labelSelectorsAttr, ok := serversM[attributes.LabelSelectors]; ok {
		labelSelectorsArr := labelSelectorsAttr.([]any)
		if selectors, labelSelectorsDiag := readServerLabelBasedSubSelectors(labelSelectorsArr); labelSelectorsDiag == nil {
			for _, selector := range selectors {
				subSelectors = append(subSelectors, client.ServerBasedResourceSubSelectorContainer{
					SelectorType: selector.ServerBasedResourceSubSelectorType(),
					Selector:     selector,
				})
			}
		} else {
			diags = append(diags, labelSelectorsDiag...)
		}
	}

	return subSelectors, diags
}

func readServerLabelBasedSubSelectors(labelSelectorsArr []any) ([]*client.ServerLabelBasedSubSelector, diag.Diagnostics) {
	var diags diag.Diagnostics

	subSelectors := make([]*client.ServerLabelBasedSubSelector, len(labelSelectorsArr))

	for idx, labelSelectorsI := range labelSelectorsArr {
		subSelector := &client.ServerLabelBasedSubSelector{}
		labelSelectorsM := labelSelectorsI.(map[string]any)

		serverLabelsI := labelSelectorsM[attributes.ServerLabels]
		serverLabelsM := serverLabelsI.(map[string]any)
		serverLabels := make(map[string]string, len(serverLabelsM))
		for k, v := range serverLabelsM {
			s := v.(string)
			if strings.ContainsAny(k, "=,") {
				diags = append(diags, diag.Diagnostic{
					Severity: diag.Error,
					Summary:  fmt.Sprintf("%s key cannot contain a ':', '=', ',' character: %s", attributes.ServerLabels, s),
				})
			}

			if strings.ContainsAny(s, ":=,") {
				diags = append(diags, diag.Diagnostic{
					Severity: diag.Error,
					Summary:  fmt.Sprintf("%s value cannot contain a ':', '=', ',' character: %s", attributes.ServerLabels, s),
				})
			}
			serverLabels[k] = s
		}
		subSelector.ServerSelector = &client.ServerLabelServerSelector{
			Labels: serverLabels,
		}

		accountsI := labelSelectorsM[attributes.Accounts]
		accountsArr := accountsI.([]any)

		var accountSelector client.AccountSelector
		if len(accountsArr) == 0 {
			accountSelector = &client.NoneAccountSelector{}
		} else {
			accounts := make([]string, len(accountsArr))
			for aIdx, accountI := range accountsArr {
				accounts[aIdx] = accountI.(string)
			}
			accountSelector = &client.UsernameAccountSelector{Usernames: accounts}
		}
		subSelector.AccountSelector = accountSelector
		subSelector.AccountSelectorType = accountSelector.AccountSelectorType()

		subSelectors[idx] = subSelector
	}

	return subSelectors, diags
}

func readIndividualServerAccountSubSelectors(serverAccountsArr []any) ([]*client.IndividualServerAccountSubSelector, diag.Diagnostics) {
	var diags diag.Diagnostics

	subSelectors := make([]*client.IndividualServerAccountSubSelector, len(serverAccountsArr))

	for idx, serverI := range serverAccountsArr {
		serverM := serverI.(map[string]any)
		serverId := serverM[attributes.ServerID].(string)
		account := serverM[attributes.Account].(string)
		if MatchesUUID(serverId) {
			subSelectors[idx] = &client.IndividualServerAccountSubSelector{
				Server:   ConvertToNamedObject(serverId, client.ServerNamedObjectType),
				Username: &account,
			}
		} else {
			diags = append(diags, diag.Diagnostic{
				Severity: diag.Error,
				Summary:  fmt.Sprintf("%s value must be a UUID: %s", attributes.ServerID, serverId),
			})
		}
	}

	return subSelectors, diags
}

func readIndividualServerSubSelectors(serversArr []any) ([]*client.IndividualServerSubSelector, diag.Diagnostics) {
	var diags diag.Diagnostics

	subSelectors := make([]*client.IndividualServerSubSelector, len(serversArr))

	for idx, serverI := range serversArr {
		serverM := serverI.(map[string]any)
		serverIdI := serverM[attributes.ServerID]
		serverId := serverIdI.(string)
		if MatchesUUID(serverId) {
			subSelectors[idx] = &client.IndividualServerSubSelector{
				Server: ConvertToNamedObject(serverId, client.ServerNamedObjectType),
			}
		} else {
			diags = append(diags, diag.Diagnostic{
				Severity: diag.Error,
				Summary:  fmt.Sprintf("server_id value must be a UUID: %s", serverId),
			})
		}
	}

	return subSelectors, diags
}

func readPrivileges(privilegesAttr []any) ([]*client.SecurityPolicyRulePrivilegeContainer, diag.Diagnostics) {
	var diags diag.Diagnostics

	privileges := make([]*client.SecurityPolicyRulePrivilegeContainer, 0, 4)
	if len(privilegesAttr) == 0 || privilegesAttr[0] == nil {
		diags = append(diags, diag.Diagnostic{
			Severity: diag.Error,
			Summary:  "must include privileges for rule",
		})
		return nil, diags
	}
	privilegesM := privilegesAttr[0].(map[string]any)

	hasRDPPriv := false
	hasSSHPriv := false

	if passwordCheckoutRDPI, ok := privilegesM[attributes.PasswordCheckoutRDP]; ok {
		if enabled, hasValue := readPrivilegeEnabled(passwordCheckoutRDPI); hasValue {
			privileges = append(privileges, &client.SecurityPolicyRulePrivilegeContainer{
				PrivilegeType: client.PasswordCheckoutRDPPrivilegeType,
				PrivilegeValue: &client.PasswordCheckoutRDPPrivilege{
					Enabled: &enabled,
				},
			})
			hasRDPPriv = hasRDPPriv || enabled
		}
	}

	if passwordCheckoutSSHI, ok := privilegesM[attributes.PasswordCheckoutSSH]; ok {
		if enabled, hasValue := readPrivilegeEnabled(passwordCheckoutSSHI); hasValue {
			privileges = append(privileges, &client.SecurityPolicyRulePrivilegeContainer{
				PrivilegeType: client.PasswordCheckoutSSHPrivilegeType,
				PrivilegeValue: &client.PasswordCheckoutSSHPrivilege{
					Enabled: &enabled,
				},
			})
			hasSSHPriv = hasSSHPriv || enabled
		}
	}

	if principalAccountRDPI, ok := privilegesM[attributes.PrincipalAccountRDP]; ok {
		if enabled, hasValue := readPrivilegeEnabled(principalAccountRDPI); hasValue {
			adminLevelPermissions := readAdminLevelPermissionEnabled(principalAccountRDPI)
			privileges = append(privileges, &client.SecurityPolicyRulePrivilegeContainer{
				PrivilegeType: client.PrincipalAccountRDPPrivilegeType,
				PrivilegeValue: &client.PrincipalAccountRDPPrivilege{
					Enabled:               &enabled,
					AdminLevelPermissions: &adminLevelPermissions,
				},
			})
			if adminLevelPermissions && !enabled {
				diags = append(diags, diag.Diagnostic{
					Severity: diag.Error,
					Summary:  "admin_level_permissions can not be enabled when principal account rdp privilege is not enabled",
				})
			}
			hasRDPPriv = hasRDPPriv || enabled
		}
	}

	if principalAccountSSHI, ok := privilegesM[attributes.PrincipalAccountSSH]; ok {
		if enabled, hasValue := readPrivilegeEnabled(principalAccountSSHI); hasValue {
			adminLevelPermissions := readAdminLevelPermissionEnabled(principalAccountSSHI)
			privileges = append(privileges, &client.SecurityPolicyRulePrivilegeContainer{
				PrivilegeType: client.PrincipalAccountSSHPrivilegeType,
				PrivilegeValue: &client.PrincipalAccountSSHPrivilege{
					Enabled:               &enabled,
					AdminLevelPermissions: &adminLevelPermissions,
				},
			})

			if adminLevelPermissions && !enabled {
				diags = append(diags, diag.Diagnostic{
					Severity: diag.Error,
					Summary:  "admin_level_permissions can not be enabled when principal account ssh privilege is not enabled",
				})
			}
			hasSSHPriv = hasSSHPriv || enabled
		}
	}

	if hasRDPPriv && hasSSHPriv {
		diags = append(diags, diag.Diagnostic{
			Severity: diag.Error,
			Summary:  "cannot mix SSH and RDP privileges within a Security Policy Rule",
		})
	}

	if secretI, ok := privilegesM[attributes.Secret]; ok {
		if secretPrivilege, secretDiags := readSecretPrivilege(secretI); secretPrivilege != nil && secretDiags == nil {
			privileges = append(privileges, &client.SecurityPolicyRulePrivilegeContainer{
				PrivilegeType:  client.SecretPrivilegeType,
				PrivilegeValue: secretPrivilege,
			})
		} else if secretDiags != nil {
			diags = append(diags, secretDiags...)
		}
	}

	return privileges, diags
}

func readSecretPrivilege(privilege any) (*client.SecretPrivilege, diag.Diagnostics) {
	var diags diag.Diagnostics
	privilegeArr := privilege.([]any)

	if len(privilegeArr) == 0 {
		return nil, nil
	}

	priv := &client.SecretPrivilege{}
	privilegeM := privilegeArr[0].(map[string]any)

	if listI, ok := privilegeM[attributes.List]; ok {
		v := listI.(bool)
		priv.List = &v
	} else {
		diags = append(diags, diag.Diagnostic{
			Severity: diag.Error,
			Summary:  fmt.Sprintf("%s is missing value for %s attribute", attributes.Secret, attributes.List),
		})
	}
	if secretFolderCreateI, ok := privilegeM[attributes.FolderCreate]; ok {
		v := secretFolderCreateI.(bool)
		priv.FolderCreate = &v
	} else {
		diags = append(diags, diag.Diagnostic{
			Severity: diag.Error,
			Summary:  fmt.Sprintf("%s is missing value for %s attribute", attributes.Secret, attributes.FolderCreate),
		})
	}
	if secretFolderDeleteI, ok := privilegeM[attributes.FolderDelete]; ok {
		v := secretFolderDeleteI.(bool)
		priv.FolderDelete = &v
	} else {
		diags = append(diags, diag.Diagnostic{
			Severity: diag.Error,
			Summary:  fmt.Sprintf("%s is missing value for %s attribute", attributes.Secret, attributes.FolderDelete),
		})
	}
	if secretFolderUpdateI, ok := privilegeM[attributes.FolderUpdate]; ok {
		v := secretFolderUpdateI.(bool)
		priv.FolderUpdate = &v
	} else {
		diags = append(diags, diag.Diagnostic{
			Severity: diag.Error,
			Summary:  fmt.Sprintf("%s is missing value for %s attribute", attributes.Secret, attributes.FolderUpdate),
		})
	}
	if secretCreateI, ok := privilegeM[attributes.SecretCreate]; ok {
		v := secretCreateI.(bool)
		priv.SecretCreate = &v
	} else {
		diags = append(diags, diag.Diagnostic{
			Severity: diag.Error,
			Summary:  fmt.Sprintf("%s is missing value for %s attribute", attributes.Secret, attributes.SecretCreate),
		})
	}
	if secretDeleteI, ok := privilegeM[attributes.SecretDelete]; ok {
		v := secretDeleteI.(bool)
		priv.SecretDelete = &v
	} else {
		diags = append(diags, diag.Diagnostic{
			Severity: diag.Error,
			Summary:  fmt.Sprintf("%s is missing value for %s attribute", attributes.Secret, attributes.SecretDelete),
		})
	}
	if secretRevealI, ok := privilegeM[attributes.SecretReveal]; ok {
		v := secretRevealI.(bool)
		priv.SecretReveal = &v
	} else {
		diags = append(diags, diag.Diagnostic{
			Severity: diag.Error,
			Summary:  fmt.Sprintf("%s is missing value for %s attribute", attributes.Secret, attributes.SecretReveal),
		})
	}
	if secretUpdateI, ok := privilegeM[attributes.SecretUpdate]; ok {
		v := secretUpdateI.(bool)
		priv.SecretUpdate = &v
	} else {
		diags = append(diags, diag.Diagnostic{
			Severity: diag.Error,
			Summary:  fmt.Sprintf("%s is missing value for %s attribute", attributes.Secret, attributes.SecretUpdate),
		})
	}

	return priv, diags
}

func readPrivilegeEnabled(privilege any) (bool, bool) {
	privilegeArr := privilege.([]any)

	if len(privilegeArr) == 0 {
		return false, false
	}

	privilegeM := privilegeArr[0].(map[string]any)

	if enabledI, ok := privilegeM[attributes.Enabled]; ok {
		return enabledI.(bool), true
	}

	return false, true
}

func readAdminLevelPermissionEnabled(privilege any) bool {
	privilegeArr := privilege.([]any)

	if len(privilegeArr) == 0 {
		return false
	}

	privilegeM := privilegeArr[0].(map[string]any)

	if adminLevelPermissions, ok := privilegeM[attributes.AdminLevelPermissions]; ok {
		return adminLevelPermissions.(bool)
	}

	return false
}

func readPrincipalsFromResourceData(d *schema.ResourceData) (*client.SecurityPolicyPrincipals, diag.Diagnostics) {
	var diags diag.Diagnostics
	principals := &client.SecurityPolicyPrincipals{}

	principalsAttr := d.Get(attributes.Principals).([]any)
	if len(principalsAttr) != 1 {
		return nil, diag.Diagnostics{
			diag.Diagnostic{
				Severity: diag.Error,
				Summary:  fmt.Sprintf("must have exactly one %s block", attributes.Principals),
			},
		}
	}

	if principalsAttr[0] == nil {
		return nil, diag.Diagnostics{
			diag.Diagnostic{
				Severity: diag.Error,
				Summary:  fmt.Sprintf("cannot have an empty %s block", attributes.Principals),
			},
		}
	}

	principalMap := principalsAttr[0].(map[string]any)
	if usersAttr, ok := principalMap[attributes.Groups]; ok {
		groups, groupsDiag := GetUUIDSlice(usersAttr, attributes.Groups)
		if groupsDiag != nil {
			diags = append(diags, groupsDiag...)
		} else {
			principals.UserGroups = ConvertToNamedObjectSlice(groups, client.UserGroupNamedObjectType)
		}
	}

	if diags == nil && len(principals.UserGroups) == 0 {
		diags = append(diags, diag.Diagnostic{
			Severity: diag.Error,
			Summary:  "must include at least one group in principals",
		})
	}

	return principals, diags
}
