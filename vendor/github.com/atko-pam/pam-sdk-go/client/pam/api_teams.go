/*
Okta Privileged Access

The OPA API is a control plane used to request operations in Okta Privileged Access (formerly ScaleFT/Advanced Server Access)

API version: 1.0.0
Contact: support@okta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pam

import (
	"context"
	"net/http"
	"net/url"
	"strings"
)

// TeamsAPIService TeamsAPI service
type TeamsAPIService service

type ApiCheckInResourceRequest struct {
	ctx                    context.Context
	ApiService             *TeamsAPIService
	teamName               string
	checkInResourceRequest *CheckInResourceRequest
}

func (r ApiCheckInResourceRequest) CheckInResourceRequest(checkInResourceRequest CheckInResourceRequest) ApiCheckInResourceRequest {
	r.checkInResourceRequest = &checkInResourceRequest
	return r
}

func (r ApiCheckInResourceRequest) Execute() (*http.Response, error) {
	return r.ApiService.CheckInResourceExecute(r)
}

/*
	CheckInResource Check in a Resource

	    Checks in a resource

This endpoint requires one of the following roles: `resource_admin`, `security_admin`, `authenticated_client`, `authenticated_service_user`, `end_user`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	@return ApiCheckInResourceRequest
*/
func (a *TeamsAPIService) CheckInResource(ctx context.Context, teamName string) ApiCheckInResourceRequest {
	return ApiCheckInResourceRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
	}
}

// Execute executes the request
func (a *TeamsAPIService) CheckInResourceExecute(r ApiCheckInResourceRequest) (*http.Response, error) {
	var (
		traceKey           = "teamsapi.checkInResource"
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localVarPath := "/v1/teams/{team_name}/checkin_resource"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.checkInResourceRequest
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, nil)

	if localVarHTTPResponse == nil && err != nil {
		return nil, err
	}

	return localVarHTTPResponse, err
}

type ApiFetchStatsForTeamRequest struct {
	ctx        context.Context
	ApiService *TeamsAPIService
	teamName   string
}

func (r ApiFetchStatsForTeamRequest) Execute() (*TeamStats, *http.Response, error) {
	return r.ApiService.FetchStatsForTeamExecute(r)
}

/*
	FetchStatsForTeam Retrieve statistics for a Team

	    Retrieves statistics about your Team

This endpoint requires one of the following roles: `resource_admin`, `security_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	@return ApiFetchStatsForTeamRequest
*/
func (a *TeamsAPIService) FetchStatsForTeam(ctx context.Context, teamName string) ApiFetchStatsForTeamRequest {
	return ApiFetchStatsForTeamRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
	}
}

// Execute executes the request
//
//	@return TeamStats
func (a *TeamsAPIService) FetchStatsForTeamExecute(r ApiFetchStatsForTeamRequest) (*TeamStats, *http.Response, error) {
	var (
		traceKey            = "teamsapi.fetchStatsForTeam"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TeamStats
	)

	localVarPath := "/v1/teams/{team_name}/team_stats"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiGetTeamSettingsRequest struct {
	ctx        context.Context
	ApiService *TeamsAPIService
	teamName   string
}

func (r ApiGetTeamSettingsRequest) Execute() (*TeamSettings, *http.Response, error) {
	return r.ApiService.GetTeamSettingsExecute(r)
}

/*
	GetTeamSettings Retrieve settings for a Team

	    Retrieves Team-level settings for your Team

This endpoint requires one of the following roles: `end_user`, `resource_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	@return ApiGetTeamSettingsRequest
*/
func (a *TeamsAPIService) GetTeamSettings(ctx context.Context, teamName string) ApiGetTeamSettingsRequest {
	return ApiGetTeamSettingsRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
	}
}

// Execute executes the request
//
//	@return TeamSettings
func (a *TeamsAPIService) GetTeamSettingsExecute(r ApiGetTeamSettingsRequest) (*TeamSettings, *http.Response, error) {
	var (
		traceKey            = "teamsapi.getTeamSettings"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TeamSettings
	)

	localVarPath := "/v1/teams/{team_name}/settings"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiGetVaultJWKSRequest struct {
	ctx        context.Context
	ApiService *TeamsAPIService
	teamName   string
}

func (r ApiGetVaultJWKSRequest) Execute() (*GetVaultJWKSResponse, *http.Response, error) {
	return r.ApiService.GetVaultJWKSExecute(r)
}

/*
GetVaultJWKS Retrieve the Vault JWKS

	Retrieves the Vault JWKS. Data sent to the vault must be encrypted to this key.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

	@param teamName The name of your Team

@return ApiGetVaultJWKSRequest
*/
func (a *TeamsAPIService) GetVaultJWKS(ctx context.Context, teamName string) ApiGetVaultJWKSRequest {
	return ApiGetVaultJWKSRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
	}
}

// Execute executes the request
//
//	@return GetVaultJWKSResponse
func (a *TeamsAPIService) GetVaultJWKSExecute(r ApiGetVaultJWKSRequest) (*GetVaultJWKSResponse, *http.Response, error) {
	var (
		traceKey            = "teamsapi.getVaultJWKS"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetVaultJWKSResponse
	)

	localVarPath := "/v1/teams/{team_name}/vault/jwks.json"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiListAllCheckedOutResourcesByUserRequest struct {
	ctx                   context.Context
	ApiService            *TeamsAPIService
	teamName              string
	resourceType          *string
	includePendingCheckin *bool
	count                 *int32
	descending            *bool
	offset                *string
	prev                  *bool
}

// If specified, only returns resources with a matching type. Valid resource types: &#x60;server_account_password_login&#x60;.
func (r ApiListAllCheckedOutResourcesByUserRequest) ResourceType(resourceType string) ApiListAllCheckedOutResourcesByUserRequest {
	r.resourceType = &resourceType
	return r
}

// If specified, also returns resources that have already started the checkin process. These are not included by default.
func (r ApiListAllCheckedOutResourcesByUserRequest) IncludePendingCheckin(includePendingCheckin bool) ApiListAllCheckedOutResourcesByUserRequest {
	r.includePendingCheckin = &includePendingCheckin
	return r
}

// The number of objects per page
func (r ApiListAllCheckedOutResourcesByUserRequest) Count(count int32) ApiListAllCheckedOutResourcesByUserRequest {
	r.count = &count
	return r
}

// The object order
func (r ApiListAllCheckedOutResourcesByUserRequest) Descending(descending bool) ApiListAllCheckedOutResourcesByUserRequest {
	r.descending = &descending
	return r
}

// The offset value for pagination. The **rel&#x3D;\&quot;next\&quot;** and **rel&#x3D;\&quot;prev\&quot;** &#x60;Link&#x60; headers define the offset for subsequent or previous pages.
func (r ApiListAllCheckedOutResourcesByUserRequest) Offset(offset string) ApiListAllCheckedOutResourcesByUserRequest {
	r.offset = &offset
	return r
}

// The direction of paging
func (r ApiListAllCheckedOutResourcesByUserRequest) Prev(prev bool) ApiListAllCheckedOutResourcesByUserRequest {
	r.prev = &prev
	return r
}

func (r ApiListAllCheckedOutResourcesByUserRequest) Execute() (*ListAllCheckedOutResourcesByUserResponse, *http.Response, error) {
	return r.ApiService.ListAllCheckedOutResourcesByUserExecute(r)
}

/*
	ListAllCheckedOutResourcesByUser List all Resources Checked Out by a User

	    Lists all resources checked out by the current user

This endpoint requires one of the following roles: `authenticated_client`, `authenticated_service_user`, `end_user`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	@return ApiListAllCheckedOutResourcesByUserRequest
*/
func (a *TeamsAPIService) ListAllCheckedOutResourcesByUser(ctx context.Context, teamName string) ApiListAllCheckedOutResourcesByUserRequest {
	return ApiListAllCheckedOutResourcesByUserRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
	}
}

// Execute executes the request
//
//	@return ListAllCheckedOutResourcesByUserResponse
func (a *TeamsAPIService) ListAllCheckedOutResourcesByUserExecute(r ApiListAllCheckedOutResourcesByUserRequest) (*ListAllCheckedOutResourcesByUserResponse, *http.Response, error) {
	var (
		traceKey            = "teamsapi.listAllCheckedOutResourcesByUser"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListAllCheckedOutResourcesByUserResponse
	)

	localVarPath := "/v1/teams/{team_name}/checked_out_resources"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.resourceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource_type", r.resourceType, "")
	}
	if r.includePendingCheckin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_pending_checkin", r.includePendingCheckin, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.prev != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prev", r.prev, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiListRolesRequest struct {
	ctx        context.Context
	ApiService *TeamsAPIService
	teamName   string
}

func (r ApiListRolesRequest) Execute() (*ListRolesResponse, *http.Response, error) {
	return r.ApiService.ListRolesExecute(r)
}

/*
	ListRoles List all roles

	    Lists all roles available to your Team

This endpoint requires one of the following roles: `pam_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	@return ApiListRolesRequest
*/
func (a *TeamsAPIService) ListRoles(ctx context.Context, teamName string) ApiListRolesRequest {
	return ApiListRolesRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
	}
}

// Execute executes the request
//
//	@return ListRolesResponse
func (a *TeamsAPIService) ListRolesExecute(r ApiListRolesRequest) (*ListRolesResponse, *http.Response, error) {
	var (
		traceKey            = "teamsapi.listRoles"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListRolesResponse
	)

	localVarPath := "/v1/teams/{team_name}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiListServersRequest struct {
	ctx                       context.Context
	ApiService                *TeamsAPIService
	teamName                  string
	adServers                 *bool
	altNamesContains          *string
	bastion                   *string
	canonicalName             *string
	cloudAccount              *string
	cloudProvider             *string
	count                     *int32
	credentialed              *bool
	descending                *bool
	hasAccountUnderManagement *bool
	hostname                  *string
	id                        *string
	instanceId                *string
	managed                   *bool
	offset                    *string
	prev                      *bool
	projectName               *string
	state                     *string
	selector                  *string
	includeLabels             *bool
}

// If &#x60;true&#x60;, only return AD servers. If &#x60;false&#x60;, only return Non-AD servers
func (r ApiListServersRequest) AdServers(adServers bool) ApiListServersRequest {
	r.adServers = &adServers
	return r
}

// Only return Servers that contain the specified alternate name
func (r ApiListServersRequest) AltNamesContains(altNamesContains string) ApiListServersRequest {
	r.altNamesContains = &altNamesContains
	return r
}

// Only return Servers associated with the specified bastion
func (r ApiListServersRequest) Bastion(bastion string) ApiListServersRequest {
	r.bastion = &bastion
	return r
}

// A canonical name
func (r ApiListServersRequest) CanonicalName(canonicalName string) ApiListServersRequest {
	r.canonicalName = &canonicalName
	return r
}

// Only return Servers associated with the specified cloud account
func (r ApiListServersRequest) CloudAccount(cloudAccount string) ApiListServersRequest {
	r.cloudAccount = &cloudAccount
	return r
}

// Only return Servers associated with the specified cloud provider. Possible values: &#x60;aws&#x60; or &#x60;gce&#x60;
func (r ApiListServersRequest) CloudProvider(cloudProvider string) ApiListServersRequest {
	r.cloudProvider = &cloudProvider
	return r
}

// The number of objects per page
func (r ApiListServersRequest) Count(count int32) ApiListServersRequest {
	r.count = &count
	return r
}

// If &#x60;true&#x60;, only return unmanaged Servers with credential issuance enabled. If &#x60;false&#x60;, only return unmanaged Servers with credential issuance disabled.
func (r ApiListServersRequest) Credentialed(credentialed bool) ApiListServersRequest {
	r.credentialed = &credentialed
	return r
}

// The object order
func (r ApiListServersRequest) Descending(descending bool) ApiListServersRequest {
	r.descending = &descending
	return r
}

// If &#x60;true&#x60;, only return Servers that currently have at least one account&#39;s password under management&#39;.  If &#x60;false&#x60;, only return servers that do not currently have an account whose password is under management.
func (r ApiListServersRequest) HasAccountUnderManagement(hasAccountUnderManagement bool) ApiListServersRequest {
	r.hasAccountUnderManagement = &hasAccountUnderManagement
	return r
}

// Only return Servers that contain the specified hostname
func (r ApiListServersRequest) Hostname(hostname string) ApiListServersRequest {
	r.hostname = &hostname
	return r
}

// Only return Servers with the specified IDs. Only usable for PAM administrative views of servers, not end-user Server views.
func (r ApiListServersRequest) Id(id string) ApiListServersRequest {
	r.id = &id
	return r
}

// Only return Servers that contain the specified instance ID
func (r ApiListServersRequest) InstanceId(instanceId string) ApiListServersRequest {
	r.instanceId = &instanceId
	return r
}

// If &#x60;true&#x60;, only return managed servers. If &#x60;false&#x60;, only return unmanaged servers.
func (r ApiListServersRequest) Managed(managed bool) ApiListServersRequest {
	r.managed = &managed
	return r
}

// The offset value for pagination. The **rel&#x3D;\&quot;next\&quot;** and **rel&#x3D;\&quot;prev\&quot;** &#x60;Link&#x60; headers define the offset for subsequent or previous pages.
func (r ApiListServersRequest) Offset(offset string) ApiListServersRequest {
	r.offset = &offset
	return r
}

// The direction of paging
func (r ApiListServersRequest) Prev(prev bool) ApiListServersRequest {
	r.prev = &prev
	return r
}

// Only return Servers that belong to the specified Project
func (r ApiListServersRequest) ProjectName(projectName string) ApiListServersRequest {
	r.projectName = &projectName
	return r
}

// Include Servers with the specified state. Valid statuses: &#x60;ACTIVE&#x60; or &#x60;INACTIVE&#x60;.
func (r ApiListServersRequest) State(state string) ApiListServersRequest {
	r.state = &state
	return r
}

// Only return Servers that contain the specified Server selectors.
func (r ApiListServersRequest) Selector(selector string) ApiListServersRequest {
	r.selector = &selector
	return r
}

// If &#x60;true&#x60;, includes server labels in the results.
func (r ApiListServersRequest) IncludeLabels(includeLabels bool) ApiListServersRequest {
	r.includeLabels = &includeLabels
	return r
}

func (r ApiListServersRequest) Execute() (*ListServersResponse, *http.Response, error) {
	return r.ApiService.ListServersExecute(r)
}

/*
	ListServers List all Servers for a Team

	    Lists all Servers in your Team. This only returns Servers available to the requesting User.

This endpoint requires the following role: `end_user`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	@return ApiListServersRequest
*/
func (a *TeamsAPIService) ListServers(ctx context.Context, teamName string) ApiListServersRequest {
	return ApiListServersRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
	}
}

// Execute executes the request
//
//	@return ListServersResponse
func (a *TeamsAPIService) ListServersExecute(r ApiListServersRequest) (*ListServersResponse, *http.Response, error) {
	var (
		traceKey            = "teamsapi.listServers"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListServersResponse
	)

	localVarPath := "/v1/teams/{team_name}/servers"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.adServers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "AdServers", r.adServers, "")
	}
	if r.altNamesContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "alt_names_contains", r.altNamesContains, "")
	}
	if r.bastion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bastion", r.bastion, "")
	}
	if r.canonicalName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "canonical_name", r.canonicalName, "")
	}
	if r.cloudAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cloud_account", r.cloudAccount, "")
	}
	if r.cloudProvider != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cloud_provider", r.cloudProvider, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.credentialed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "credentialed", r.credentialed, "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "")
	}
	if r.hasAccountUnderManagement != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_account_under_management", r.hasAccountUnderManagement, "")
	}
	if r.hostname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hostname", r.hostname, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_id", r.instanceId, "")
	}
	if r.managed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "managed", r.managed, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.prev != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prev", r.prev, "")
	}
	if r.projectName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "project_name", r.projectName, "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.selector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "selector", r.selector, "")
	}
	if r.includeLabels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_labels", r.includeLabels, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiUpdateTeamSettingsRequest struct {
	ctx          context.Context
	ApiService   *TeamsAPIService
	teamName     string
	teamSettings *TeamSettings
}

func (r ApiUpdateTeamSettingsRequest) TeamSettings(teamSettings TeamSettings) ApiUpdateTeamSettingsRequest {
	r.teamSettings = &teamSettings
	return r
}

func (r ApiUpdateTeamSettingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateTeamSettingsExecute(r)
}

/*
	UpdateTeamSettings Update settings for a Team

	    Updates Team-level settings for your Team. Partial updates are permitted. To disable a setting, set the value to `null`.

This endpoint requires the following role: `resource_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	@return ApiUpdateTeamSettingsRequest
*/
func (a *TeamsAPIService) UpdateTeamSettings(ctx context.Context, teamName string) ApiUpdateTeamSettingsRequest {
	return ApiUpdateTeamSettingsRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
	}
}

// Execute executes the request
func (a *TeamsAPIService) UpdateTeamSettingsExecute(r ApiUpdateTeamSettingsRequest) (*http.Response, error) {
	var (
		traceKey           = "teamsapi.updateTeamSettings"
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localVarPath := "/v1/teams/{team_name}/settings"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.teamSettings == nil {
		return nil, reportError("teamSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.teamSettings
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, nil)

	if localVarHTTPResponse == nil && err != nil {
		return nil, err
	}

	return localVarHTTPResponse, err
}
