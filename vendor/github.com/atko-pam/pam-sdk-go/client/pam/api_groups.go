/*
Okta Privileged Access

The OPA API is a control plane used to request operations in Okta Privileged Access (formerly ScaleFT/Advanced Server Access)

API version: 1.0.0
Contact: support@okta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pam

import (
	"context"
	"net/http"
	"net/url"
	"strings"
)

// GroupsAPIService GroupsAPI service
type GroupsAPIService service

type ApiAddUserToGroupRequest struct {
	ctx                   context.Context
	ApiService            *GroupsAPIService
	teamName              string
	groupName             string
	addUserToGroupRequest *AddUserToGroupRequest
}

func (r ApiAddUserToGroupRequest) AddUserToGroupRequest(addUserToGroupRequest AddUserToGroupRequest) ApiAddUserToGroupRequest {
	r.addUserToGroupRequest = &addUserToGroupRequest
	return r
}

func (r ApiAddUserToGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddUserToGroupExecute(r)
}

/*
	AddUserToGroup Add a User to a Group

	    Adds a User to a Group

This endpoint requires the following role: `pam_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param groupName The name of a Group
	@return ApiAddUserToGroupRequest
*/
func (a *GroupsAPIService) AddUserToGroup(ctx context.Context, teamName string, groupName string) ApiAddUserToGroupRequest {
	return ApiAddUserToGroupRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
		groupName:  groupName,
	}
}

// Execute executes the request
func (a *GroupsAPIService) AddUserToGroupExecute(r ApiAddUserToGroupRequest) (*http.Response, error) {
	var (
		traceKey           = "groupsapi.addUserToGroup"
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localVarPath := "/v1/teams/{team_name}/groups/{group_name}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addUserToGroupRequest == nil {
		return nil, reportError("addUserToGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addUserToGroupRequest
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, nil)

	if localVarHTTPResponse == nil && err != nil {
		return nil, err
	}

	return localVarHTTPResponse, err
}

type ApiCreateGroupRequest struct {
	ctx         context.Context
	ApiService  *GroupsAPIService
	teamName    string
	groupCreate *GroupCreate
}

func (r ApiCreateGroupRequest) GroupCreate(groupCreate GroupCreate) ApiCreateGroupRequest {
	r.groupCreate = &groupCreate
	return r
}

func (r ApiCreateGroupRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.CreateGroupExecute(r)
}

/*
	CreateGroup Create a Group

	    Creates a Group for your Team. Groups allow you to assign RBAC roles to users and manage user access to Resource Groups and Projects. To assign the `delegated_resource_admin` role, you need to add the Group to the `delegated_resource_admin_groups` list for a specific Resource Group. See [Resource Groups](/openapi/opa/opa/tag/resource-groups).

This endpoint requires the following role: `pam_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	@return ApiCreateGroupRequest
*/
func (a *GroupsAPIService) CreateGroup(ctx context.Context, teamName string) ApiCreateGroupRequest {
	return ApiCreateGroupRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
	}
}

// Execute executes the request
//
//	@return Group
func (a *GroupsAPIService) CreateGroupExecute(r ApiCreateGroupRequest) (*Group, *http.Response, error) {
	var (
		traceKey            = "groupsapi.createGroup"
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Group
	)

	localVarPath := "/v1/teams/{team_name}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupCreate
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiGetGroupRequest struct {
	ctx        context.Context
	ApiService *GroupsAPIService
	teamName   string
	groupName  string
}

func (r ApiGetGroupRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.GetGroupExecute(r)
}

/*
	GetGroup Retrieve a Group

	    Retrieves a specified Group

This endpoint requires one of the following roles: `pam_admin`, `resource_admin`, `delegated_resource_admin`, `security_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param groupName The name of a Group
	@return ApiGetGroupRequest
*/
func (a *GroupsAPIService) GetGroup(ctx context.Context, teamName string, groupName string) ApiGetGroupRequest {
	return ApiGetGroupRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
		groupName:  groupName,
	}
}

// Execute executes the request
//
//	@return Group
func (a *GroupsAPIService) GetGroupExecute(r ApiGetGroupRequest) (*Group, *http.Response, error) {
	var (
		traceKey            = "groupsapi.getGroup"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Group
	)

	localVarPath := "/v1/teams/{team_name}/groups/{group_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiListGroupsRequest struct {
	ctx                context.Context
	ApiService         *GroupsAPIService
	teamName           string
	contains           *string
	count              *int32
	descending         *bool
	id                 *string
	ignore             *string
	includeDeleted     *bool
	offset             *string
	onlyIncludeDeleted *bool
	prev               *bool
}

// Only return results that include the specified value
func (r ApiListGroupsRequest) Contains(contains string) ApiListGroupsRequest {
	r.contains = &contains
	return r
}

// The number of objects per page
func (r ApiListGroupsRequest) Count(count int32) ApiListGroupsRequest {
	r.count = &count
	return r
}

// The object order
func (r ApiListGroupsRequest) Descending(descending bool) ApiListGroupsRequest {
	r.descending = &descending
	return r
}

// Only return results with the specified IDs
func (r ApiListGroupsRequest) Id(id string) ApiListGroupsRequest {
	r.id = &id
	return r
}

// Ignore Groups with the specified names. This is case sensitive.
func (r ApiListGroupsRequest) Ignore(ignore string) ApiListGroupsRequest {
	r.ignore = &ignore
	return r
}

// If &#x60;true&#x60;, include deleted Groups in the results
func (r ApiListGroupsRequest) IncludeDeleted(includeDeleted bool) ApiListGroupsRequest {
	r.includeDeleted = &includeDeleted
	return r
}

// The offset value for pagination. The **rel&#x3D;\&quot;next\&quot;** and **rel&#x3D;\&quot;prev\&quot;** &#x60;Link&#x60; headers define the offset for subsequent or previous pages.
func (r ApiListGroupsRequest) Offset(offset string) ApiListGroupsRequest {
	r.offset = &offset
	return r
}

// If &#x60;true&#x60;, only return deleted Groups in the results
func (r ApiListGroupsRequest) OnlyIncludeDeleted(onlyIncludeDeleted bool) ApiListGroupsRequest {
	r.onlyIncludeDeleted = &onlyIncludeDeleted
	return r
}

// The direction of paging
func (r ApiListGroupsRequest) Prev(prev bool) ApiListGroupsRequest {
	r.prev = &prev
	return r
}

func (r ApiListGroupsRequest) Execute() (*ListGroupsResponse, *http.Response, error) {
	return r.ApiService.ListGroupsExecute(r)
}

/*
	ListGroups List all Groups for a Team

	    Lists all Groups for your Team

This endpoint requires one of the following roles: `pam_admin`, `resource_admin`, `delegated_resource_admin`, `security_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	@return ApiListGroupsRequest
*/
func (a *GroupsAPIService) ListGroups(ctx context.Context, teamName string) ApiListGroupsRequest {
	return ApiListGroupsRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
	}
}

// Execute executes the request
//
//	@return ListGroupsResponse
func (a *GroupsAPIService) ListGroupsExecute(r ApiListGroupsRequest) (*ListGroupsResponse, *http.Response, error) {
	var (
		traceKey            = "groupsapi.listGroups"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListGroupsResponse
	)

	localVarPath := "/v1/teams/{team_name}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contains", r.contains, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.ignore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore", r.ignore, "")
	}
	if r.includeDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_deleted", r.includeDeleted, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.onlyIncludeDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_include_deleted", r.onlyIncludeDeleted, "")
	}
	if r.prev != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prev", r.prev, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiListUsersInGroupRequest struct {
	ctx        context.Context
	ApiService *GroupsAPIService
	teamName   string
	groupName  string
	contains   *string
	count      *int32
	descending *bool
	offset     *string
	prev       *bool
	startsWith *string
	status     *string
	userType   *string
}

// Only return results that include the specified value
func (r ApiListUsersInGroupRequest) Contains(contains string) ApiListUsersInGroupRequest {
	r.contains = &contains
	return r
}

// The number of objects per page
func (r ApiListUsersInGroupRequest) Count(count int32) ApiListUsersInGroupRequest {
	r.count = &count
	return r
}

// The object order
func (r ApiListUsersInGroupRequest) Descending(descending bool) ApiListUsersInGroupRequest {
	r.descending = &descending
	return r
}

// The offset value for pagination. The **rel&#x3D;\&quot;next\&quot;** and **rel&#x3D;\&quot;prev\&quot;** &#x60;Link&#x60; headers define the offset for subsequent or previous pages.
func (r ApiListUsersInGroupRequest) Offset(offset string) ApiListUsersInGroupRequest {
	r.offset = &offset
	return r
}

// The direction of paging
func (r ApiListUsersInGroupRequest) Prev(prev bool) ApiListUsersInGroupRequest {
	r.prev = &prev
	return r
}

// Only return Users with a name that begins with the specified value
func (r ApiListUsersInGroupRequest) StartsWith(startsWith string) ApiListUsersInGroupRequest {
	r.startsWith = &startsWith
	return r
}

// Only return Users with the specified status. Valid statuses: &#x60;ACTIVE&#x60;, &#x60;DISABLED&#x60;, and &#x60;DELETED&#x60;.
func (r ApiListUsersInGroupRequest) Status(status string) ApiListUsersInGroupRequest {
	r.status = &status
	return r
}

// Only return Users of the specified type. Valid types: &#x60;human&#x60; and &#x60;service&#x60;.
func (r ApiListUsersInGroupRequest) UserType(userType string) ApiListUsersInGroupRequest {
	r.userType = &userType
	return r
}

func (r ApiListUsersInGroupRequest) Execute() (*ListUsersInGroupResponse, *http.Response, error) {
	return r.ApiService.ListUsersInGroupExecute(r)
}

/*
	ListUsersInGroup List all Users for a Group

	    Lists all Users in a specified Group

This endpoint requires one of the following roles: `pam_admin`, `resource_admin`, `delegated_resource_admin`, `security_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param groupName The name of a Group
	@return ApiListUsersInGroupRequest
*/
func (a *GroupsAPIService) ListUsersInGroup(ctx context.Context, teamName string, groupName string) ApiListUsersInGroupRequest {
	return ApiListUsersInGroupRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
		groupName:  groupName,
	}
}

// Execute executes the request
//
//	@return ListUsersInGroupResponse
func (a *GroupsAPIService) ListUsersInGroupExecute(r ApiListUsersInGroupRequest) (*ListUsersInGroupResponse, *http.Response, error) {
	var (
		traceKey            = "groupsapi.listUsersInGroup"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListUsersInGroupResponse
	)

	localVarPath := "/v1/teams/{team_name}/groups/{group_name}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contains", r.contains, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.prev != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prev", r.prev, "")
	}
	if r.startsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "starts_with", r.startsWith, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.userType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_type", r.userType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiRemoveGroupRequest struct {
	ctx        context.Context
	ApiService *GroupsAPIService
	teamName   string
	groupName  string
}

func (r ApiRemoveGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveGroupExecute(r)
}

/*
	RemoveGroup Delete a Group from a Team

	    Removes a Group from your Team. This also removes the Group from any associated Projects.

This endpoint requires the following role: `pam_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param groupName The name of a Group
	@return ApiRemoveGroupRequest
*/
func (a *GroupsAPIService) RemoveGroup(ctx context.Context, teamName string, groupName string) ApiRemoveGroupRequest {
	return ApiRemoveGroupRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
		groupName:  groupName,
	}
}

// Execute executes the request
func (a *GroupsAPIService) RemoveGroupExecute(r ApiRemoveGroupRequest) (*http.Response, error) {
	var (
		traceKey           = "groupsapi.removeGroup"
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localVarPath := "/v1/teams/{team_name}/groups/{group_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, nil)

	if localVarHTTPResponse == nil && err != nil {
		return nil, err
	}

	return localVarHTTPResponse, err
}

type ApiRemoveUserFromGroupRequest struct {
	ctx        context.Context
	ApiService *GroupsAPIService
	teamName   string
	groupName  string
	userName   string
}

func (r ApiRemoveUserFromGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveUserFromGroupExecute(r)
}

/*
	RemoveUserFromGroup Remove a User from a Group

	    Removes a User from a Group

This endpoint requires the following role: `pam_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param groupName The name of a Group
	    @param userName The username for an existing User
	@return ApiRemoveUserFromGroupRequest
*/
func (a *GroupsAPIService) RemoveUserFromGroup(ctx context.Context, teamName string, groupName string, userName string) ApiRemoveUserFromGroupRequest {
	return ApiRemoveUserFromGroupRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
		groupName:  groupName,
		userName:   userName,
	}
}

// Execute executes the request
func (a *GroupsAPIService) RemoveUserFromGroupExecute(r ApiRemoveUserFromGroupRequest) (*http.Response, error) {
	var (
		traceKey           = "groupsapi.removeUserFromGroup"
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localVarPath := "/v1/teams/{team_name}/groups/{group_name}/users/{user_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_name"+"}", url.PathEscape(parameterValueToString(r.userName, "userName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, nil)

	if localVarHTTPResponse == nil && err != nil {
		return nil, err
	}

	return localVarHTTPResponse, err
}

type ApiUpdateGroupRequest struct {
	ctx         context.Context
	ApiService  *GroupsAPIService
	teamName    string
	groupName   string
	groupUpdate *GroupUpdate
}

func (r ApiUpdateGroupRequest) GroupUpdate(groupUpdate GroupUpdate) ApiUpdateGroupRequest {
	r.groupUpdate = &groupUpdate
	return r
}

func (r ApiUpdateGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateGroupExecute(r)
}

/*
	UpdateGroup Update a Group

	    Updates the access privileges of the specified Group. To assign the `delegated_resource_admin` role, you need to add the Group to the `delegated_resource_admin_groups` list for a specific Resource Group. See [Resource Groups](/openapi/opa/opa/tag/resource-groups).

This endpoint requires the following role: `pam_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param groupName The name of a Group
	@return ApiUpdateGroupRequest
*/
func (a *GroupsAPIService) UpdateGroup(ctx context.Context, teamName string, groupName string) ApiUpdateGroupRequest {
	return ApiUpdateGroupRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
		groupName:  groupName,
	}
}

// Execute executes the request
func (a *GroupsAPIService) UpdateGroupExecute(r ApiUpdateGroupRequest) (*http.Response, error) {
	var (
		traceKey           = "groupsapi.updateGroup"
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localVarPath := "/v1/teams/{team_name}/groups/{group_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupUpdate == nil {
		return nil, reportError("groupUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupUpdate
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, nil)

	if localVarHTTPResponse == nil && err != nil {
		return nil, err
	}

	return localVarHTTPResponse, err
}
