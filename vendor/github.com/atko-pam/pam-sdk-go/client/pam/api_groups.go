/*
Okta Privileged Access

The Okta Privileged Access API is a control plane used to request operations in Okta Privileged Access (formerly ScaleFT/Advanced Server Access)

API version: 1.0.0
Contact: support@okta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pam

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// GroupsAPIService GroupsAPI service
type GroupsAPIService service

type ApiAddUserToGroupRequest struct {
	ctx                   context.Context
	ApiService            *GroupsAPIService
	teamName              string
	groupName             string
	addUserToGroupRequest *AddUserToGroupRequest
}

func (r ApiAddUserToGroupRequest) AddUserToGroupRequest(addUserToGroupRequest AddUserToGroupRequest) ApiAddUserToGroupRequest {
	r.addUserToGroupRequest = &addUserToGroupRequest
	return r
}

func (r ApiAddUserToGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddUserToGroupExecute(r)
}

/*
AddUserToGroup Add a user to a group

	Adds a user to a group

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

	@param teamName The name of your team
	@param groupName The name of a group

@return ApiAddUserToGroupRequest
*/
func (a *GroupsAPIService) AddUserToGroup(ctx context.Context, teamName string, groupName string) ApiAddUserToGroupRequest {
	return ApiAddUserToGroupRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
		groupName:  groupName,
	}
}

// Execute executes the request
func (a *GroupsAPIService) AddUserToGroupExecute(r ApiAddUserToGroupRequest) (*http.Response, error) {
	var (
		traceKey           = "groupsapi.addUserToGroup"
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localVarPath := "/v1/teams/{team_name}/groups/{group_name}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addUserToGroupRequest == nil {
		return nil, reportError("addUserToGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addUserToGroupRequest
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, nil)

	if err != nil {
		if localVarHTTPResponse == nil {
			return nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarHTTPResponse, err
		}
		return localVarHTTPResponse, apiError
	}

	return localVarHTTPResponse, err
}

type ApiCreateGroupRequest struct {
	ctx         context.Context
	ApiService  *GroupsAPIService
	teamName    string
	groupCreate *GroupCreate
}

func (r ApiCreateGroupRequest) GroupCreate(groupCreate GroupCreate) ApiCreateGroupRequest {
	r.groupCreate = &groupCreate
	return r
}

func (r ApiCreateGroupRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.CreateGroupExecute(r)
}

/*
CreateGroup Create a group

	Creates a group for your team. Groups allow you to assign RBAC roles to users and manage user access to resource groups and projects. To assign the `delegated_resource_admin` role, you need to add the group to the `delegated_resource_admin_groups` list for a specific resource group. See [Resource Groups](/openapi/opa/opa/tag/resource-groups).

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

	@param teamName The name of your team

@return ApiCreateGroupRequest
*/
func (a *GroupsAPIService) CreateGroup(ctx context.Context, teamName string) ApiCreateGroupRequest {
	return ApiCreateGroupRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
	}
}

// Execute executes the request
//
//	@return Group
func (a *GroupsAPIService) CreateGroupExecute(r ApiCreateGroupRequest) (*Group, *http.Response, error) {
	var (
		traceKey            = "groupsapi.createGroup"
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Group
	)

	localVarPath := "/v1/teams/{team_name}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupCreate
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if err != nil {
		if localVarHTTPResponse == nil {
			return localVarReturnValue, nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return localVarReturnValue, nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		return localVarReturnValue, localVarHTTPResponse, apiError
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiGetGroupRequest struct {
	ctx        context.Context
	ApiService *GroupsAPIService
	teamName   string
	groupName  string
}

func (r ApiGetGroupRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.GetGroupExecute(r)
}

/*
GetGroup Retrieve a group

	Retrieves a specified group

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

	@param teamName The name of your team
	@param groupName The name of a group

@return ApiGetGroupRequest
*/
func (a *GroupsAPIService) GetGroup(ctx context.Context, teamName string, groupName string) ApiGetGroupRequest {
	return ApiGetGroupRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
		groupName:  groupName,
	}
}

// Execute executes the request
//
//	@return Group
func (a *GroupsAPIService) GetGroupExecute(r ApiGetGroupRequest) (*Group, *http.Response, error) {
	var (
		traceKey            = "groupsapi.getGroup"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Group
	)

	localVarPath := "/v1/teams/{team_name}/groups/{group_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if err != nil {
		if localVarHTTPResponse == nil {
			return localVarReturnValue, nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return localVarReturnValue, nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		return localVarReturnValue, localVarHTTPResponse, apiError
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiListGroupsRequest struct {
	ctx                context.Context
	ApiService         *GroupsAPIService
	teamName           string
	contains           *string
	count              *int32
	descending         *bool
	id                 *string
	ignore             *string
	includeDeleted     *bool
	offset             *string
	onlyIncludeDeleted *bool
	prev               *bool
}

// Only return results that include the specified value
func (r ApiListGroupsRequest) Contains(contains string) ApiListGroupsRequest {
	r.contains = &contains
	return r
}

// The number of objects per page
func (r ApiListGroupsRequest) Count(count int32) ApiListGroupsRequest {
	r.count = &count
	return r
}

// The object order
func (r ApiListGroupsRequest) Descending(descending bool) ApiListGroupsRequest {
	r.descending = &descending
	return r
}

// Only return results with the specified IDs
func (r ApiListGroupsRequest) Id(id string) ApiListGroupsRequest {
	r.id = &id
	return r
}

// Ignore groups with the specified names. This is case sensitive.
func (r ApiListGroupsRequest) Ignore(ignore string) ApiListGroupsRequest {
	r.ignore = &ignore
	return r
}

// If &#x60;true&#x60;, include deleted groups in the results
func (r ApiListGroupsRequest) IncludeDeleted(includeDeleted bool) ApiListGroupsRequest {
	r.includeDeleted = &includeDeleted
	return r
}

// The offset value for pagination. The **rel&#x3D;\&quot;next\&quot;** and **rel&#x3D;\&quot;prev\&quot;** &#x60;Link&#x60; headers define the offset for subsequent or previous pages.
func (r ApiListGroupsRequest) Offset(offset string) ApiListGroupsRequest {
	r.offset = &offset
	return r
}

// If &#x60;true&#x60;, only return deleted groups in the results
func (r ApiListGroupsRequest) OnlyIncludeDeleted(onlyIncludeDeleted bool) ApiListGroupsRequest {
	r.onlyIncludeDeleted = &onlyIncludeDeleted
	return r
}

// The direction of paging
func (r ApiListGroupsRequest) Prev(prev bool) ApiListGroupsRequest {
	r.prev = &prev
	return r
}

func (r ApiListGroupsRequest) Execute() (*ListGroupsResponse, *http.Response, error) {
	return r.ApiService.ListGroupsExecute(r)
}

/*
ListGroups List all groups for a team

	Lists all groups for your team

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

	@param teamName The name of your team

@return ApiListGroupsRequest
*/
func (a *GroupsAPIService) ListGroups(ctx context.Context, teamName string) ApiListGroupsRequest {
	return ApiListGroupsRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
	}
}

// Execute executes the request
//
//	@return ListGroupsResponse
func (a *GroupsAPIService) ListGroupsExecute(r ApiListGroupsRequest) (*ListGroupsResponse, *http.Response, error) {
	var (
		traceKey            = "groupsapi.listGroups"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListGroupsResponse
	)

	localVarPath := "/v1/teams/{team_name}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contains", r.contains, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.ignore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore", r.ignore, "")
	}
	if r.includeDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_deleted", r.includeDeleted, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.onlyIncludeDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_include_deleted", r.onlyIncludeDeleted, "")
	}
	if r.prev != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prev", r.prev, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if err != nil {
		if localVarHTTPResponse == nil {
			return localVarReturnValue, nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return localVarReturnValue, nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		return localVarReturnValue, localVarHTTPResponse, apiError
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiListUsersInGroupRequest struct {
	ctx        context.Context
	ApiService *GroupsAPIService
	teamName   string
	groupName  string
	contains   *string
	count      *int32
	descending *bool
	offset     *string
	prev       *bool
	startsWith *string
	status     *string
	userType   *string
}

// Only return results that include the specified value
func (r ApiListUsersInGroupRequest) Contains(contains string) ApiListUsersInGroupRequest {
	r.contains = &contains
	return r
}

// The number of objects per page
func (r ApiListUsersInGroupRequest) Count(count int32) ApiListUsersInGroupRequest {
	r.count = &count
	return r
}

// The object order
func (r ApiListUsersInGroupRequest) Descending(descending bool) ApiListUsersInGroupRequest {
	r.descending = &descending
	return r
}

// The offset value for pagination. The **rel&#x3D;\&quot;next\&quot;** and **rel&#x3D;\&quot;prev\&quot;** &#x60;Link&#x60; headers define the offset for subsequent or previous pages.
func (r ApiListUsersInGroupRequest) Offset(offset string) ApiListUsersInGroupRequest {
	r.offset = &offset
	return r
}

// The direction of paging
func (r ApiListUsersInGroupRequest) Prev(prev bool) ApiListUsersInGroupRequest {
	r.prev = &prev
	return r
}

// Only return users with a name that begins with the specified value
func (r ApiListUsersInGroupRequest) StartsWith(startsWith string) ApiListUsersInGroupRequest {
	r.startsWith = &startsWith
	return r
}

// Only return users with the specified status. Valid statuses: &#x60;ACTIVE&#x60;, &#x60;DISABLED&#x60;, and &#x60;DELETED&#x60;.
func (r ApiListUsersInGroupRequest) Status(status string) ApiListUsersInGroupRequest {
	r.status = &status
	return r
}

// Only return users of the specified type. Valid types: &#x60;human&#x60; and &#x60;service&#x60;.
func (r ApiListUsersInGroupRequest) UserType(userType string) ApiListUsersInGroupRequest {
	r.userType = &userType
	return r
}

func (r ApiListUsersInGroupRequest) Execute() (*ListUsersInGroupResponse, *http.Response, error) {
	return r.ApiService.ListUsersInGroupExecute(r)
}

/*
ListUsersInGroup List all users for a group

	Lists all users in a specified group

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

	@param teamName The name of your team
	@param groupName The name of a group

@return ApiListUsersInGroupRequest
*/
func (a *GroupsAPIService) ListUsersInGroup(ctx context.Context, teamName string, groupName string) ApiListUsersInGroupRequest {
	return ApiListUsersInGroupRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
		groupName:  groupName,
	}
}

// Execute executes the request
//
//	@return ListUsersInGroupResponse
func (a *GroupsAPIService) ListUsersInGroupExecute(r ApiListUsersInGroupRequest) (*ListUsersInGroupResponse, *http.Response, error) {
	var (
		traceKey            = "groupsapi.listUsersInGroup"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListUsersInGroupResponse
	)

	localVarPath := "/v1/teams/{team_name}/groups/{group_name}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contains", r.contains, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.prev != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prev", r.prev, "")
	}
	if r.startsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "starts_with", r.startsWith, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.userType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_type", r.userType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if err != nil {
		if localVarHTTPResponse == nil {
			return localVarReturnValue, nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return localVarReturnValue, nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		return localVarReturnValue, localVarHTTPResponse, apiError
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiRemoveGroupRequest struct {
	ctx        context.Context
	ApiService *GroupsAPIService
	teamName   string
	groupName  string
}

func (r ApiRemoveGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveGroupExecute(r)
}

/*
RemoveGroup Delete a group from a team

	Removes a group from your team. This also removes the group from any associated projects.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

	@param teamName The name of your team
	@param groupName The name of a group

@return ApiRemoveGroupRequest
*/
func (a *GroupsAPIService) RemoveGroup(ctx context.Context, teamName string, groupName string) ApiRemoveGroupRequest {
	return ApiRemoveGroupRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
		groupName:  groupName,
	}
}

// Execute executes the request
func (a *GroupsAPIService) RemoveGroupExecute(r ApiRemoveGroupRequest) (*http.Response, error) {
	var (
		traceKey           = "groupsapi.removeGroup"
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localVarPath := "/v1/teams/{team_name}/groups/{group_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, nil)

	if err != nil {
		if localVarHTTPResponse == nil {
			return nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarHTTPResponse, err
		}
		return localVarHTTPResponse, apiError
	}

	return localVarHTTPResponse, err
}

type ApiRemoveUserFromGroupRequest struct {
	ctx        context.Context
	ApiService *GroupsAPIService
	teamName   string
	groupName  string
	userName   string
}

func (r ApiRemoveUserFromGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveUserFromGroupExecute(r)
}

/*
RemoveUserFromGroup Remove a user from a group

	Removes a user from a group

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

	@param teamName The name of your team
	@param groupName The name of a group
	@param userName The username for an existing user

@return ApiRemoveUserFromGroupRequest
*/
func (a *GroupsAPIService) RemoveUserFromGroup(ctx context.Context, teamName string, groupName string, userName string) ApiRemoveUserFromGroupRequest {
	return ApiRemoveUserFromGroupRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
		groupName:  groupName,
		userName:   userName,
	}
}

// Execute executes the request
func (a *GroupsAPIService) RemoveUserFromGroupExecute(r ApiRemoveUserFromGroupRequest) (*http.Response, error) {
	var (
		traceKey           = "groupsapi.removeUserFromGroup"
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localVarPath := "/v1/teams/{team_name}/groups/{group_name}/users/{user_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_name"+"}", url.PathEscape(parameterValueToString(r.userName, "userName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, nil)

	if err != nil {
		if localVarHTTPResponse == nil {
			return nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarHTTPResponse, err
		}
		return localVarHTTPResponse, apiError
	}

	return localVarHTTPResponse, err
}

type ApiUpdateGroupRequest struct {
	ctx         context.Context
	ApiService  *GroupsAPIService
	teamName    string
	groupName   string
	groupUpdate *GroupUpdate
}

func (r ApiUpdateGroupRequest) GroupUpdate(groupUpdate GroupUpdate) ApiUpdateGroupRequest {
	r.groupUpdate = &groupUpdate
	return r
}

func (r ApiUpdateGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateGroupExecute(r)
}

/*
UpdateGroup Update a group

	Updates the access privileges of the specified group. To assign the `delegated_resource_admin` role, you need to add the group to the `delegated_resource_admin_groups` list for a specific resource group. See [Resource Groups](/openapi/opa/opa/tag/resource-groups).

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

	@param teamName The name of your team
	@param groupName The name of a group

@return ApiUpdateGroupRequest
*/
func (a *GroupsAPIService) UpdateGroup(ctx context.Context, teamName string, groupName string) ApiUpdateGroupRequest {
	return ApiUpdateGroupRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
		groupName:  groupName,
	}
}

// Execute executes the request
func (a *GroupsAPIService) UpdateGroupExecute(r ApiUpdateGroupRequest) (*http.Response, error) {
	var (
		traceKey           = "groupsapi.updateGroup"
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localVarPath := "/v1/teams/{team_name}/groups/{group_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupUpdate == nil {
		return nil, reportError("groupUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupUpdate
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, nil)

	if err != nil {
		if localVarHTTPResponse == nil {
			return nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarHTTPResponse, err
		}
		return localVarHTTPResponse, apiError
	}

	return localVarHTTPResponse, err
}
