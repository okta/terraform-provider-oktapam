/*
Okta Privileged Access

The OPA API is a control plane used to request operations in Okta Privileged Access (formerly ScaleFT/Advanced Server Access)

API version: 1.0.0
Contact: support@okta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pam

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// ActiveDirectoryAccountsAPIService ActiveDirectoryAccountsAPI service
type ActiveDirectoryAccountsAPIService service

type ApiConfigureActiveDirectoryAccountRuleSettingsRequest struct {
	ctx                                context.Context
	ApiService                         *ActiveDirectoryAccountsAPIService
	teamName                           string
	adConnectionId                     string
	activeDirectoryAccountRuleSettings *ActiveDirectoryAccountRuleSettings
}

func (r ApiConfigureActiveDirectoryAccountRuleSettingsRequest) ActiveDirectoryAccountRuleSettings(activeDirectoryAccountRuleSettings ActiveDirectoryAccountRuleSettings) ApiConfigureActiveDirectoryAccountRuleSettingsRequest {
	r.activeDirectoryAccountRuleSettings = &activeDirectoryAccountRuleSettings
	return r
}

func (r ApiConfigureActiveDirectoryAccountRuleSettingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConfigureActiveDirectoryAccountRuleSettingsExecute(r)
}

/*
	ConfigureActiveDirectoryAccountRuleSettings Configure account rule settings

	    Account rule settings apply to the entire list of account rules and are required to be configured.

This endpoint requires the following role: `resource_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param adConnectionId The UUID of a Active Directory Connection
	@return ApiConfigureActiveDirectoryAccountRuleSettingsRequest
*/
func (a *ActiveDirectoryAccountsAPIService) ConfigureActiveDirectoryAccountRuleSettings(ctx context.Context, teamName string, adConnectionId string) ApiConfigureActiveDirectoryAccountRuleSettingsRequest {
	return ApiConfigureActiveDirectoryAccountRuleSettingsRequest{
		ApiService:     a,
		ctx:            ctx,
		teamName:       teamName,
		adConnectionId: adConnectionId,
	}
}

// Execute executes the request
func (a *ActiveDirectoryAccountsAPIService) ConfigureActiveDirectoryAccountRuleSettingsExecute(r ApiConfigureActiveDirectoryAccountRuleSettingsRequest) (*http.Response, error) {
	var (
		traceKey           = "activedirectoryaccountsapi.configureActiveDirectoryAccountRuleSettings"
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localVarPath := "/v1/teams/{team_name}/resource_assignment/active_directory/{ad_connection_id}/rule_settings"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ad_connection_id"+"}", url.PathEscape(parameterValueToString(r.adConnectionId, "adConnectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.activeDirectoryAccountRuleSettings == nil {
		return nil, reportError("activeDirectoryAccountRuleSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.activeDirectoryAccountRuleSettings
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, nil)

	if localVarHTTPResponse == nil && err != nil {
		return nil, err
	}

	if localVarHTTPResponse.StatusCode == 401 {

		localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarHTTPResponse, err
		}

		var nonDefaultResponse ErrNonDefaultResponse
		var v UnauthorizedAccessResponse
		if err := json.Unmarshal(localVarBody, &v); err != nil {
			return localVarHTTPResponse, err
		}
		nonDefaultResponse.Result = v
		nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
		return localVarHTTPResponse, nonDefaultResponse
	}
	if localVarHTTPResponse.StatusCode == 404 {

		localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarHTTPResponse, err
		}

		var nonDefaultResponse ErrNonDefaultResponse
		var v NotFoundResponse
		if err := json.Unmarshal(localVarBody, &v); err != nil {
			return localVarHTTPResponse, err
		}
		nonDefaultResponse.Result = v
		nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
		return localVarHTTPResponse, nonDefaultResponse
	}

	return localVarHTTPResponse, err
}

type ApiCreateActiveDirectoryAccountRuleRequest struct {
	ctx                               context.Context
	ApiService                        *ActiveDirectoryAccountsAPIService
	teamName                          string
	adConnectionId                    string
	activeDirectoryAccountRuleRequest *ActiveDirectoryAccountRuleRequest
}

func (r ApiCreateActiveDirectoryAccountRuleRequest) ActiveDirectoryAccountRuleRequest(activeDirectoryAccountRuleRequest ActiveDirectoryAccountRuleRequest) ApiCreateActiveDirectoryAccountRuleRequest {
	r.activeDirectoryAccountRuleRequest = &activeDirectoryAccountRuleRequest
	return r
}

func (r ApiCreateActiveDirectoryAccountRuleRequest) Execute() (*ActiveDirectoryAccountRuleResponse, *http.Response, error) {
	return r.ApiService.CreateActiveDirectoryAccountRuleExecute(r)
}

/*
	CreateActiveDirectoryAccountRule Create an Active Directory account rule

	    Create an Active Directory account rule

This endpoint requires the following role: `resource_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param adConnectionId The UUID of a Active Directory Connection
	@return ApiCreateActiveDirectoryAccountRuleRequest
*/
func (a *ActiveDirectoryAccountsAPIService) CreateActiveDirectoryAccountRule(ctx context.Context, teamName string, adConnectionId string) ApiCreateActiveDirectoryAccountRuleRequest {
	return ApiCreateActiveDirectoryAccountRuleRequest{
		ApiService:     a,
		ctx:            ctx,
		teamName:       teamName,
		adConnectionId: adConnectionId,
	}
}

// Execute executes the request
//
//	@return ActiveDirectoryAccountRuleResponse
func (a *ActiveDirectoryAccountsAPIService) CreateActiveDirectoryAccountRuleExecute(r ApiCreateActiveDirectoryAccountRuleRequest) (*ActiveDirectoryAccountRuleResponse, *http.Response, error) {
	var (
		traceKey            = "activedirectoryaccountsapi.createActiveDirectoryAccountRule"
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ActiveDirectoryAccountRuleResponse
	)

	localVarPath := "/v1/teams/{team_name}/resource_assignment/active_directory/{ad_connection_id}/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ad_connection_id"+"}", url.PathEscape(parameterValueToString(r.adConnectionId, "adConnectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.activeDirectoryAccountRuleRequest == nil {
		return localVarReturnValue, nil, reportError("activeDirectoryAccountRuleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.activeDirectoryAccountRuleRequest
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	if localVarHTTPResponse.StatusCode == 401 {

		localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return nil, localVarHTTPResponse, err
		}

		var nonDefaultResponse ErrNonDefaultResponse
		var v UnauthorizedAccessResponse
		if err := json.Unmarshal(localVarBody, &v); err != nil {
			return nil, localVarHTTPResponse, err
		}
		nonDefaultResponse.Result = v
		nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
		return nil, localVarHTTPResponse, nonDefaultResponse
	}
	if localVarHTTPResponse.StatusCode == 404 {

		localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return nil, localVarHTTPResponse, err
		}

		var nonDefaultResponse ErrNonDefaultResponse
		var v NotFoundResponse
		if err := json.Unmarshal(localVarBody, &v); err != nil {
			return nil, localVarHTTPResponse, err
		}
		nonDefaultResponse.Result = v
		nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
		return nil, localVarHTTPResponse, nonDefaultResponse
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiDeleteActiveDirectoryAccountRuleRequest struct {
	ctx             context.Context
	ApiService      *ActiveDirectoryAccountsAPIService
	teamName        string
	adConnectionId  string
	adAccountRuleId string
}

func (r ApiDeleteActiveDirectoryAccountRuleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteActiveDirectoryAccountRuleExecute(r)
}

/*
	DeleteActiveDirectoryAccountRule Delete an Active Directory account rule

	    Deletes the Active Directory account rule

This endpoint requires the following role: `resource_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param adConnectionId The UUID of a Active Directory Connection
	    @param adAccountRuleId The UUID of a Active Directory account rule
	@return ApiDeleteActiveDirectoryAccountRuleRequest
*/
func (a *ActiveDirectoryAccountsAPIService) DeleteActiveDirectoryAccountRule(ctx context.Context, teamName string, adConnectionId string, adAccountRuleId string) ApiDeleteActiveDirectoryAccountRuleRequest {
	return ApiDeleteActiveDirectoryAccountRuleRequest{
		ApiService:      a,
		ctx:             ctx,
		teamName:        teamName,
		adConnectionId:  adConnectionId,
		adAccountRuleId: adAccountRuleId,
	}
}

// Execute executes the request
func (a *ActiveDirectoryAccountsAPIService) DeleteActiveDirectoryAccountRuleExecute(r ApiDeleteActiveDirectoryAccountRuleRequest) (*http.Response, error) {
	var (
		traceKey           = "activedirectoryaccountsapi.deleteActiveDirectoryAccountRule"
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localVarPath := "/v1/teams/{team_name}/resource_assignment/active_directory/{ad_connection_id}/rules/{ad_account_rule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ad_connection_id"+"}", url.PathEscape(parameterValueToString(r.adConnectionId, "adConnectionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ad_account_rule_id"+"}", url.PathEscape(parameterValueToString(r.adAccountRuleId, "adAccountRuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, nil)

	if localVarHTTPResponse == nil && err != nil {
		return nil, err
	}

	if localVarHTTPResponse.StatusCode == 401 {

		localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarHTTPResponse, err
		}

		var nonDefaultResponse ErrNonDefaultResponse
		var v UnauthorizedAccessResponse
		if err := json.Unmarshal(localVarBody, &v); err != nil {
			return localVarHTTPResponse, err
		}
		nonDefaultResponse.Result = v
		nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
		return localVarHTTPResponse, nonDefaultResponse
	}
	if localVarHTTPResponse.StatusCode == 404 {

		localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarHTTPResponse, err
		}

		var nonDefaultResponse ErrNonDefaultResponse
		var v NotFoundResponse
		if err := json.Unmarshal(localVarBody, &v); err != nil {
			return localVarHTTPResponse, err
		}
		nonDefaultResponse.Result = v
		nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
		return localVarHTTPResponse, nonDefaultResponse
	}

	return localVarHTTPResponse, err
}

type ApiGetActiveDirectoryAccountRequest struct {
	ctx            context.Context
	ApiService     *ActiveDirectoryAccountsAPIService
	teamName       string
	adConnectionId string
	adAccountId    string
}

func (r ApiGetActiveDirectoryAccountRequest) Execute() (*ActiveDirectoryAccount, *http.Response, error) {
	return r.ApiService.GetActiveDirectoryAccountExecute(r)
}

/*
	GetActiveDirectoryAccount Fetch a particular Active Directory account by ID

	    Fetches a particular Active Directory account by ID.

This endpoint requires the following role: `resource_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param adConnectionId The UUID of a Active Directory Connection
	    @param adAccountId The UUID of an Active Directory Account
	@return ApiGetActiveDirectoryAccountRequest
*/
func (a *ActiveDirectoryAccountsAPIService) GetActiveDirectoryAccount(ctx context.Context, teamName string, adConnectionId string, adAccountId string) ApiGetActiveDirectoryAccountRequest {
	return ApiGetActiveDirectoryAccountRequest{
		ApiService:     a,
		ctx:            ctx,
		teamName:       teamName,
		adConnectionId: adConnectionId,
		adAccountId:    adAccountId,
	}
}

// Execute executes the request
//
//	@return ActiveDirectoryAccount
func (a *ActiveDirectoryAccountsAPIService) GetActiveDirectoryAccountExecute(r ApiGetActiveDirectoryAccountRequest) (*ActiveDirectoryAccount, *http.Response, error) {
	var (
		traceKey            = "activedirectoryaccountsapi.getActiveDirectoryAccount"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ActiveDirectoryAccount
	)

	localVarPath := "/v1/teams/{team_name}/resource_assignment/active_directory/{ad_connection_id}/accounts/{ad_account_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ad_connection_id"+"}", url.PathEscape(parameterValueToString(r.adConnectionId, "adConnectionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ad_account_id"+"}", url.PathEscape(parameterValueToString(r.adAccountId, "adAccountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	if localVarHTTPResponse.StatusCode == 401 {

		localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return nil, localVarHTTPResponse, err
		}

		var nonDefaultResponse ErrNonDefaultResponse
		var v UnauthorizedAccessResponse
		if err := json.Unmarshal(localVarBody, &v); err != nil {
			return nil, localVarHTTPResponse, err
		}
		nonDefaultResponse.Result = v
		nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
		return nil, localVarHTTPResponse, nonDefaultResponse
	}
	if localVarHTTPResponse.StatusCode == 404 {

		localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return nil, localVarHTTPResponse, err
		}

		var nonDefaultResponse ErrNonDefaultResponse
		var v NotFoundResponse
		if err := json.Unmarshal(localVarBody, &v); err != nil {
			return nil, localVarHTTPResponse, err
		}
		nonDefaultResponse.Result = v
		nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
		return nil, localVarHTTPResponse, nonDefaultResponse
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiGetActiveDirectoryAccountMatchRequest struct {
	ctx            context.Context
	ApiService     *ActiveDirectoryAccountsAPIService
	teamName       string
	adConnectionId string
	adAccountId    string
}

func (r ApiGetActiveDirectoryAccountMatchRequest) Execute() (*ActiveDirectoryAccountMatchResponse, *http.Response, error) {
	return r.ApiService.GetActiveDirectoryAccountMatchExecute(r)
}

/*
	GetActiveDirectoryAccountMatch Get information about an Active Directory account's match with an Okta Privileged Access user.

	    Returns information about the given Active Directory account's match status. This is only valid for individual

Active Directory accounts, not shared accounts. Matches between AD accounts and Okta users are controlled by
the Active Directory account rules for this connection.
This endpoint requires the following role: `resource_admin`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param adConnectionId The UUID of a Active Directory Connection
	    @param adAccountId The UUID of an Active Directory Account
	@return ApiGetActiveDirectoryAccountMatchRequest
*/
func (a *ActiveDirectoryAccountsAPIService) GetActiveDirectoryAccountMatch(ctx context.Context, teamName string, adConnectionId string, adAccountId string) ApiGetActiveDirectoryAccountMatchRequest {
	return ApiGetActiveDirectoryAccountMatchRequest{
		ApiService:     a,
		ctx:            ctx,
		teamName:       teamName,
		adConnectionId: adConnectionId,
		adAccountId:    adAccountId,
	}
}

// Execute executes the request
//
//	@return ActiveDirectoryAccountMatchResponse
func (a *ActiveDirectoryAccountsAPIService) GetActiveDirectoryAccountMatchExecute(r ApiGetActiveDirectoryAccountMatchRequest) (*ActiveDirectoryAccountMatchResponse, *http.Response, error) {
	var (
		traceKey            = "activedirectoryaccountsapi.getActiveDirectoryAccountMatch"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ActiveDirectoryAccountMatchResponse
	)

	localVarPath := "/v1/teams/{team_name}/resource_assignment/active_directory/{ad_connection_id}/accounts/{ad_account_id}/match"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ad_connection_id"+"}", url.PathEscape(parameterValueToString(r.adConnectionId, "adConnectionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ad_account_id"+"}", url.PathEscape(parameterValueToString(r.adAccountId, "adAccountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	if localVarHTTPResponse.StatusCode == 401 {

		localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return nil, localVarHTTPResponse, err
		}

		var nonDefaultResponse ErrNonDefaultResponse
		var v UnauthorizedAccessResponse
		if err := json.Unmarshal(localVarBody, &v); err != nil {
			return nil, localVarHTTPResponse, err
		}
		nonDefaultResponse.Result = v
		nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
		return nil, localVarHTTPResponse, nonDefaultResponse
	}
	if localVarHTTPResponse.StatusCode == 404 {

		localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return nil, localVarHTTPResponse, err
		}

		var nonDefaultResponse ErrNonDefaultResponse
		var v NotFoundResponse
		if err := json.Unmarshal(localVarBody, &v); err != nil {
			return nil, localVarHTTPResponse, err
		}
		nonDefaultResponse.Result = v
		nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
		return nil, localVarHTTPResponse, nonDefaultResponse
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiGetActiveDirectoryAccountRuleRequest struct {
	ctx             context.Context
	ApiService      *ActiveDirectoryAccountsAPIService
	teamName        string
	adConnectionId  string
	adAccountRuleId string
}

func (r ApiGetActiveDirectoryAccountRuleRequest) Execute() (*ActiveDirectoryAccountRuleResponse, *http.Response, error) {
	return r.ApiService.GetActiveDirectoryAccountRuleExecute(r)
}

/*
	GetActiveDirectoryAccountRule Retrieve an Active Directory account rule

	    Retrieves the specified Active Directory account rule

This endpoint requires the following role: `resource_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param adConnectionId The UUID of a Active Directory Connection
	    @param adAccountRuleId The UUID of a Active Directory account rule
	@return ApiGetActiveDirectoryAccountRuleRequest
*/
func (a *ActiveDirectoryAccountsAPIService) GetActiveDirectoryAccountRule(ctx context.Context, teamName string, adConnectionId string, adAccountRuleId string) ApiGetActiveDirectoryAccountRuleRequest {
	return ApiGetActiveDirectoryAccountRuleRequest{
		ApiService:      a,
		ctx:             ctx,
		teamName:        teamName,
		adConnectionId:  adConnectionId,
		adAccountRuleId: adAccountRuleId,
	}
}

// Execute executes the request
//
//	@return ActiveDirectoryAccountRuleResponse
func (a *ActiveDirectoryAccountsAPIService) GetActiveDirectoryAccountRuleExecute(r ApiGetActiveDirectoryAccountRuleRequest) (*ActiveDirectoryAccountRuleResponse, *http.Response, error) {
	var (
		traceKey            = "activedirectoryaccountsapi.getActiveDirectoryAccountRule"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ActiveDirectoryAccountRuleResponse
	)

	localVarPath := "/v1/teams/{team_name}/resource_assignment/active_directory/{ad_connection_id}/rules/{ad_account_rule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ad_connection_id"+"}", url.PathEscape(parameterValueToString(r.adConnectionId, "adConnectionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ad_account_rule_id"+"}", url.PathEscape(parameterValueToString(r.adAccountRuleId, "adAccountRuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiGetActiveDirectoryAccountRuleSettingsRequest struct {
	ctx            context.Context
	ApiService     *ActiveDirectoryAccountsAPIService
	teamName       string
	adConnectionId string
}

func (r ApiGetActiveDirectoryAccountRuleSettingsRequest) Execute() (*ActiveDirectoryAccountRuleSettings, *http.Response, error) {
	return r.ApiService.GetActiveDirectoryAccountRuleSettingsExecute(r)
}

/*
	GetActiveDirectoryAccountRuleSettings Retrieve Active Directory account rule settings

	    Retrieves Active Directory account rule settings.

This endpoint requires the following role: `resource_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param adConnectionId The UUID of a Active Directory Connection
	@return ApiGetActiveDirectoryAccountRuleSettingsRequest
*/
func (a *ActiveDirectoryAccountsAPIService) GetActiveDirectoryAccountRuleSettings(ctx context.Context, teamName string, adConnectionId string) ApiGetActiveDirectoryAccountRuleSettingsRequest {
	return ApiGetActiveDirectoryAccountRuleSettingsRequest{
		ApiService:     a,
		ctx:            ctx,
		teamName:       teamName,
		adConnectionId: adConnectionId,
	}
}

// Execute executes the request
//
//	@return ActiveDirectoryAccountRuleSettings
func (a *ActiveDirectoryAccountsAPIService) GetActiveDirectoryAccountRuleSettingsExecute(r ApiGetActiveDirectoryAccountRuleSettingsRequest) (*ActiveDirectoryAccountRuleSettings, *http.Response, error) {
	var (
		traceKey            = "activedirectoryaccountsapi.getActiveDirectoryAccountRuleSettings"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ActiveDirectoryAccountRuleSettings
	)

	localVarPath := "/v1/teams/{team_name}/resource_assignment/active_directory/{ad_connection_id}/rule_settings"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ad_connection_id"+"}", url.PathEscape(parameterValueToString(r.adConnectionId, "adConnectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	if localVarHTTPResponse.StatusCode == 401 {

		localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return nil, localVarHTTPResponse, err
		}

		var nonDefaultResponse ErrNonDefaultResponse
		var v UnauthorizedAccessResponse
		if err := json.Unmarshal(localVarBody, &v); err != nil {
			return nil, localVarHTTPResponse, err
		}
		nonDefaultResponse.Result = v
		nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
		return nil, localVarHTTPResponse, nonDefaultResponse
	}
	if localVarHTTPResponse.StatusCode == 404 {

		localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return nil, localVarHTTPResponse, err
		}

		var nonDefaultResponse ErrNonDefaultResponse
		var v NotFoundResponse
		if err := json.Unmarshal(localVarBody, &v); err != nil {
			return nil, localVarHTTPResponse, err
		}
		nonDefaultResponse.Result = v
		nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
		return nil, localVarHTTPResponse, nonDefaultResponse
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiListActiveDirectoryAccountRulesRequest struct {
	ctx            context.Context
	ApiService     *ActiveDirectoryAccountsAPIService
	teamName       string
	adConnectionId string
}

func (r ApiListActiveDirectoryAccountRulesRequest) Execute() (*ListActiveDirectoryAccountRulesResponse, *http.Response, error) {
	return r.ApiService.ListActiveDirectoryAccountRulesExecute(r)
}

/*
	ListActiveDirectoryAccountRules List all Active Directory account rules

	    Lists all Active Directory account rules

This endpoint requires the following role: `resource_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param adConnectionId The UUID of a Active Directory Connection
	@return ApiListActiveDirectoryAccountRulesRequest
*/
func (a *ActiveDirectoryAccountsAPIService) ListActiveDirectoryAccountRules(ctx context.Context, teamName string, adConnectionId string) ApiListActiveDirectoryAccountRulesRequest {
	return ApiListActiveDirectoryAccountRulesRequest{
		ApiService:     a,
		ctx:            ctx,
		teamName:       teamName,
		adConnectionId: adConnectionId,
	}
}

// Execute executes the request
//
//	@return ListActiveDirectoryAccountRulesResponse
func (a *ActiveDirectoryAccountsAPIService) ListActiveDirectoryAccountRulesExecute(r ApiListActiveDirectoryAccountRulesRequest) (*ListActiveDirectoryAccountRulesResponse, *http.Response, error) {
	var (
		traceKey            = "activedirectoryaccountsapi.listActiveDirectoryAccountRules"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListActiveDirectoryAccountRulesResponse
	)

	localVarPath := "/v1/teams/{team_name}/resource_assignment/active_directory/{ad_connection_id}/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ad_connection_id"+"}", url.PathEscape(parameterValueToString(r.adConnectionId, "adConnectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	if localVarHTTPResponse.StatusCode == 401 {

		localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return nil, localVarHTTPResponse, err
		}

		var nonDefaultResponse ErrNonDefaultResponse
		var v UnauthorizedAccessResponse
		if err := json.Unmarshal(localVarBody, &v); err != nil {
			return nil, localVarHTTPResponse, err
		}
		nonDefaultResponse.Result = v
		nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
		return nil, localVarHTTPResponse, nonDefaultResponse
	}
	if localVarHTTPResponse.StatusCode == 404 {

		localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return nil, localVarHTTPResponse, err
		}

		var nonDefaultResponse ErrNonDefaultResponse
		var v NotFoundResponse
		if err := json.Unmarshal(localVarBody, &v); err != nil {
			return nil, localVarHTTPResponse, err
		}
		nonDefaultResponse.Result = v
		nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
		return nil, localVarHTTPResponse, nonDefaultResponse
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiListActiveDirectoryAccountsRequest struct {
	ctx            context.Context
	ApiService     *ActiveDirectoryAccountsAPIService
	teamName       string
	adConnectionId string
}

func (r ApiListActiveDirectoryAccountsRequest) Execute() (*ListActiveDirectoryAccountsResponse, *http.Response, error) {
	return r.ApiService.ListActiveDirectoryAccountsExecute(r)
}

/*
	ListActiveDirectoryAccounts List discovered Active Directory accounts

	    Lists discovered Active Directory accounts.

This endpoint requires the following role: `resource_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param adConnectionId The UUID of a Active Directory Connection
	@return ApiListActiveDirectoryAccountsRequest
*/
func (a *ActiveDirectoryAccountsAPIService) ListActiveDirectoryAccounts(ctx context.Context, teamName string, adConnectionId string) ApiListActiveDirectoryAccountsRequest {
	return ApiListActiveDirectoryAccountsRequest{
		ApiService:     a,
		ctx:            ctx,
		teamName:       teamName,
		adConnectionId: adConnectionId,
	}
}

// Execute executes the request
//
//	@return ListActiveDirectoryAccountsResponse
func (a *ActiveDirectoryAccountsAPIService) ListActiveDirectoryAccountsExecute(r ApiListActiveDirectoryAccountsRequest) (*ListActiveDirectoryAccountsResponse, *http.Response, error) {
	var (
		traceKey            = "activedirectoryaccountsapi.listActiveDirectoryAccounts"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListActiveDirectoryAccountsResponse
	)

	localVarPath := "/v1/teams/{team_name}/resource_assignment/active_directory/{ad_connection_id}/accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ad_connection_id"+"}", url.PathEscape(parameterValueToString(r.adConnectionId, "adConnectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	if localVarHTTPResponse.StatusCode == 401 {

		localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return nil, localVarHTTPResponse, err
		}

		var nonDefaultResponse ErrNonDefaultResponse
		var v UnauthorizedAccessResponse
		if err := json.Unmarshal(localVarBody, &v); err != nil {
			return nil, localVarHTTPResponse, err
		}
		nonDefaultResponse.Result = v
		nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
		return nil, localVarHTTPResponse, nonDefaultResponse
	}
	if localVarHTTPResponse.StatusCode == 404 {

		localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return nil, localVarHTTPResponse, err
		}

		var nonDefaultResponse ErrNonDefaultResponse
		var v NotFoundResponse
		if err := json.Unmarshal(localVarBody, &v); err != nil {
			return nil, localVarHTTPResponse, err
		}
		nonDefaultResponse.Result = v
		nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
		return nil, localVarHTTPResponse, nonDefaultResponse
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiReorderActiveDirectoryAccountRulesRequest struct {
	ctx                                      context.Context
	ApiService                               *ActiveDirectoryAccountsAPIService
	teamName                                 string
	adConnectionId                           string
	reorderActiveDirectoryAccountRuleRequest *[]ReorderActiveDirectoryAccountRuleRequest
}

func (r ApiReorderActiveDirectoryAccountRulesRequest) ReorderActiveDirectoryAccountRuleRequest(reorderActiveDirectoryAccountRuleRequest []ReorderActiveDirectoryAccountRuleRequest) ApiReorderActiveDirectoryAccountRulesRequest {
	r.reorderActiveDirectoryAccountRuleRequest = &reorderActiveDirectoryAccountRuleRequest
	return r
}

func (r ApiReorderActiveDirectoryAccountRulesRequest) Execute() (*ReorderActiveDirectoryAccountRulesResponse, *http.Response, error) {
	return r.ApiService.ReorderActiveDirectoryAccountRulesExecute(r)
}

/*
	ReorderActiveDirectoryAccountRules Reorder priority of Active Directory account rules

	    Reorders the priority of Active Directory account rules

This endpoint requires the following role: `resource_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param adConnectionId The UUID of a Active Directory Connection
	@return ApiReorderActiveDirectoryAccountRulesRequest
*/
func (a *ActiveDirectoryAccountsAPIService) ReorderActiveDirectoryAccountRules(ctx context.Context, teamName string, adConnectionId string) ApiReorderActiveDirectoryAccountRulesRequest {
	return ApiReorderActiveDirectoryAccountRulesRequest{
		ApiService:     a,
		ctx:            ctx,
		teamName:       teamName,
		adConnectionId: adConnectionId,
	}
}

// Execute executes the request
//
//	@return ReorderActiveDirectoryAccountRulesResponse
func (a *ActiveDirectoryAccountsAPIService) ReorderActiveDirectoryAccountRulesExecute(r ApiReorderActiveDirectoryAccountRulesRequest) (*ReorderActiveDirectoryAccountRulesResponse, *http.Response, error) {
	var (
		traceKey            = "activedirectoryaccountsapi.reorderActiveDirectoryAccountRules"
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ReorderActiveDirectoryAccountRulesResponse
	)

	localVarPath := "/v1/teams/{team_name}/resource_assignment/active_directory/{ad_connection_id}/rules/reorder"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ad_connection_id"+"}", url.PathEscape(parameterValueToString(r.adConnectionId, "adConnectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reorderActiveDirectoryAccountRuleRequest
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	if localVarHTTPResponse.StatusCode == 400 {

		localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return nil, localVarHTTPResponse, err
		}

		var nonDefaultResponse ErrNonDefaultResponse
		var v BadRequestResponse
		if err := json.Unmarshal(localVarBody, &v); err != nil {
			return nil, localVarHTTPResponse, err
		}
		nonDefaultResponse.Result = v
		nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
		return nil, localVarHTTPResponse, nonDefaultResponse
	}
	if localVarHTTPResponse.StatusCode == 401 {

		localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return nil, localVarHTTPResponse, err
		}

		var nonDefaultResponse ErrNonDefaultResponse
		var v UnauthorizedAccessResponse
		if err := json.Unmarshal(localVarBody, &v); err != nil {
			return nil, localVarHTTPResponse, err
		}
		nonDefaultResponse.Result = v
		nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
		return nil, localVarHTTPResponse, nonDefaultResponse
	}
	if localVarHTTPResponse.StatusCode == 404 {

		localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return nil, localVarHTTPResponse, err
		}

		var nonDefaultResponse ErrNonDefaultResponse
		var v NotFoundResponse
		if err := json.Unmarshal(localVarBody, &v); err != nil {
			return nil, localVarHTTPResponse, err
		}
		nonDefaultResponse.Result = v
		nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
		return nil, localVarHTTPResponse, nonDefaultResponse
	}
	if localVarHTTPResponse.StatusCode == 409 {

		localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return nil, localVarHTTPResponse, err
		}

		var nonDefaultResponse ErrNonDefaultResponse
		var v ConflictResponse
		if err := json.Unmarshal(localVarBody, &v); err != nil {
			return nil, localVarHTTPResponse, err
		}
		nonDefaultResponse.Result = v
		nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
		return nil, localVarHTTPResponse, nonDefaultResponse
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiUpdateActiveDirectoryAccountMatchRequest struct {
	ctx                                context.Context
	ApiService                         *ActiveDirectoryAccountsAPIService
	teamName                           string
	adConnectionId                     string
	adAccountId                        string
	activeDirectoryAccountMatchRequest *ActiveDirectoryAccountMatchRequest
}

func (r ApiUpdateActiveDirectoryAccountMatchRequest) ActiveDirectoryAccountMatchRequest(activeDirectoryAccountMatchRequest ActiveDirectoryAccountMatchRequest) ApiUpdateActiveDirectoryAccountMatchRequest {
	r.activeDirectoryAccountMatchRequest = &activeDirectoryAccountMatchRequest
	return r
}

func (r ApiUpdateActiveDirectoryAccountMatchRequest) Execute() (*ActiveDirectoryAccountMatchResponse, *http.Response, error) {
	return r.ApiService.UpdateActiveDirectoryAccountMatchExecute(r)
}

/*
	UpdateActiveDirectoryAccountMatch Update which Okta Privileged Access user an Active Directory account matches

	    Updates which Okta Privileged Access user an Active Directory account matches, overriding any match configured

as the result of an Active Directory account rule. This match override will persist across any updates
to the account rules for this connection.
This endpoint requires the following role: `resource_admin`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param adConnectionId The UUID of a Active Directory Connection
	    @param adAccountId The UUID of an Active Directory Account
	@return ApiUpdateActiveDirectoryAccountMatchRequest
*/
func (a *ActiveDirectoryAccountsAPIService) UpdateActiveDirectoryAccountMatch(ctx context.Context, teamName string, adConnectionId string, adAccountId string) ApiUpdateActiveDirectoryAccountMatchRequest {
	return ApiUpdateActiveDirectoryAccountMatchRequest{
		ApiService:     a,
		ctx:            ctx,
		teamName:       teamName,
		adConnectionId: adConnectionId,
		adAccountId:    adAccountId,
	}
}

// Execute executes the request
//
//	@return ActiveDirectoryAccountMatchResponse
func (a *ActiveDirectoryAccountsAPIService) UpdateActiveDirectoryAccountMatchExecute(r ApiUpdateActiveDirectoryAccountMatchRequest) (*ActiveDirectoryAccountMatchResponse, *http.Response, error) {
	var (
		traceKey            = "activedirectoryaccountsapi.updateActiveDirectoryAccountMatch"
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ActiveDirectoryAccountMatchResponse
	)

	localVarPath := "/v1/teams/{team_name}/resource_assignment/active_directory/{ad_connection_id}/accounts/{ad_account_id}/match"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ad_connection_id"+"}", url.PathEscape(parameterValueToString(r.adConnectionId, "adConnectionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ad_account_id"+"}", url.PathEscape(parameterValueToString(r.adAccountId, "adAccountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.activeDirectoryAccountMatchRequest
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	if localVarHTTPResponse.StatusCode == 401 {

		localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return nil, localVarHTTPResponse, err
		}

		var nonDefaultResponse ErrNonDefaultResponse
		var v UnauthorizedAccessResponse
		if err := json.Unmarshal(localVarBody, &v); err != nil {
			return nil, localVarHTTPResponse, err
		}
		nonDefaultResponse.Result = v
		nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
		return nil, localVarHTTPResponse, nonDefaultResponse
	}
	if localVarHTTPResponse.StatusCode == 404 {

		localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return nil, localVarHTTPResponse, err
		}

		var nonDefaultResponse ErrNonDefaultResponse
		var v NotFoundResponse
		if err := json.Unmarshal(localVarBody, &v); err != nil {
			return nil, localVarHTTPResponse, err
		}
		nonDefaultResponse.Result = v
		nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
		return nil, localVarHTTPResponse, nonDefaultResponse
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiUpdateActiveDirectoryAccountRuleRequest struct {
	ctx                               context.Context
	ApiService                        *ActiveDirectoryAccountsAPIService
	teamName                          string
	adConnectionId                    string
	adAccountRuleId                   string
	activeDirectoryAccountRuleRequest *ActiveDirectoryAccountRuleRequest
}

func (r ApiUpdateActiveDirectoryAccountRuleRequest) ActiveDirectoryAccountRuleRequest(activeDirectoryAccountRuleRequest ActiveDirectoryAccountRuleRequest) ApiUpdateActiveDirectoryAccountRuleRequest {
	r.activeDirectoryAccountRuleRequest = &activeDirectoryAccountRuleRequest
	return r
}

func (r ApiUpdateActiveDirectoryAccountRuleRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateActiveDirectoryAccountRuleExecute(r)
}

/*
	UpdateActiveDirectoryAccountRule Update an Active Directory account rule

	    Updates the Active Directory account rule

This endpoint requires the following role: `resource_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param adConnectionId The UUID of a Active Directory Connection
	    @param adAccountRuleId The UUID of a Active Directory account rule
	@return ApiUpdateActiveDirectoryAccountRuleRequest
*/
func (a *ActiveDirectoryAccountsAPIService) UpdateActiveDirectoryAccountRule(ctx context.Context, teamName string, adConnectionId string, adAccountRuleId string) ApiUpdateActiveDirectoryAccountRuleRequest {
	return ApiUpdateActiveDirectoryAccountRuleRequest{
		ApiService:      a,
		ctx:             ctx,
		teamName:        teamName,
		adConnectionId:  adConnectionId,
		adAccountRuleId: adAccountRuleId,
	}
}

// Execute executes the request
func (a *ActiveDirectoryAccountsAPIService) UpdateActiveDirectoryAccountRuleExecute(r ApiUpdateActiveDirectoryAccountRuleRequest) (*http.Response, error) {
	var (
		traceKey           = "activedirectoryaccountsapi.updateActiveDirectoryAccountRule"
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localVarPath := "/v1/teams/{team_name}/resource_assignment/active_directory/{ad_connection_id}/rules/{ad_account_rule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ad_connection_id"+"}", url.PathEscape(parameterValueToString(r.adConnectionId, "adConnectionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ad_account_rule_id"+"}", url.PathEscape(parameterValueToString(r.adAccountRuleId, "adAccountRuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.activeDirectoryAccountRuleRequest
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, nil)

	if localVarHTTPResponse == nil && err != nil {
		return nil, err
	}

	return localVarHTTPResponse, err
}
