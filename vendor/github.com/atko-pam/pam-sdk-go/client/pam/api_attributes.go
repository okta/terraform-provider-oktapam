/*
Okta Privileged Access

The ScaleFT API is a control plane API for operations in Okta Privileged Access (formerly ScaleFT)

API version: 1.0.0
Contact: support@okta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pam

import (
	"context"
	"net/http"
	"net/url"
	"strings"
)

// AttributesAPIService AttributesAPI service
type AttributesAPIService service

type ApiFetchGroupAttributeRequest struct {
	ctx         context.Context
	ApiService  *AttributesAPIService
	teamName    string
	groupName   string
	attributeId string
}

func (r ApiFetchGroupAttributeRequest) Execute() (*TeamGroupAttribute, *http.Response, error) {
	return r.ApiService.FetchGroupAttributeExecute(r)
}

/*
	FetchGroupAttribute Retrieve a Group Attribute

	    Retrieves an Attribute for a Group

This endpoint requires one of the following roles: `resource_admin`, `delegated_resource_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param groupName The name of the Group
	    @param attributeId The UUID of the Attribute
	@return ApiFetchGroupAttributeRequest
*/
func (a *AttributesAPIService) FetchGroupAttribute(ctx context.Context, teamName string, groupName string, attributeId string) ApiFetchGroupAttributeRequest {
	return ApiFetchGroupAttributeRequest{
		ApiService:  a,
		ctx:         ctx,
		teamName:    teamName,
		groupName:   groupName,
		attributeId: attributeId,
	}
}

// Execute executes the request
//
//	@return TeamGroupAttribute
func (a *AttributesAPIService) FetchGroupAttributeExecute(r ApiFetchGroupAttributeRequest) (*TeamGroupAttribute, *http.Response, error) {
	var (
		traceKey            = "attributesapi.fetchGroupAttribute"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TeamGroupAttribute
	)

	localVarPath := "/v1/teams/{team_name}/groups/{group_name}/attributes/{attribute_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attribute_id"+"}", url.PathEscape(parameterValueToString(r.attributeId, "attributeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiFetchUserAttributeRequest struct {
	ctx         context.Context
	ApiService  *AttributesAPIService
	teamName    string
	userName    string
	attributeId string
}

func (r ApiFetchUserAttributeRequest) Execute() (*TeamUserAttribute, *http.Response, error) {
	return r.ApiService.FetchUserAttributeExecute(r)
}

/*
	FetchUserAttribute Retrieve a User Attribute

	    Retrieves an Attribute for a User

This endpoint requires the following role: `resource_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param userName The relevant username
	    @param attributeId The UUID of the Attribute
	@return ApiFetchUserAttributeRequest
*/
func (a *AttributesAPIService) FetchUserAttribute(ctx context.Context, teamName string, userName string, attributeId string) ApiFetchUserAttributeRequest {
	return ApiFetchUserAttributeRequest{
		ApiService:  a,
		ctx:         ctx,
		teamName:    teamName,
		userName:    userName,
		attributeId: attributeId,
	}
}

// Execute executes the request
//
//	@return TeamUserAttribute
func (a *AttributesAPIService) FetchUserAttributeExecute(r ApiFetchUserAttributeRequest) (*TeamUserAttribute, *http.Response, error) {
	var (
		traceKey            = "attributesapi.fetchUserAttribute"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TeamUserAttribute
	)

	localVarPath := "/v1/teams/{team_name}/users/{user_name}/attributes/{attribute_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_name"+"}", url.PathEscape(parameterValueToString(r.userName, "userName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attribute_id"+"}", url.PathEscape(parameterValueToString(r.attributeId, "attributeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiListGroupAttributesRequest struct {
	ctx         context.Context
	ApiService  *AttributesAPIService
	teamName    string
	groupName   string
	offset      *string
	count       *int32
	descending  *bool
	prev        *bool
	conflicting *bool
}

// The offset value for pagination. The **rel&#x3D;\&quot;next\&quot;** and **rel&#x3D;\&quot;prev\&quot;** &#x60;Link&#x60; headers define the offset for subsequent or previous pages.
func (r ApiListGroupAttributesRequest) Offset(offset string) ApiListGroupAttributesRequest {
	r.offset = &offset
	return r
}

// The number of objects per page
func (r ApiListGroupAttributesRequest) Count(count int32) ApiListGroupAttributesRequest {
	r.count = &count
	return r
}

// The object order
func (r ApiListGroupAttributesRequest) Descending(descending bool) ApiListGroupAttributesRequest {
	r.descending = &descending
	return r
}

// The direction of paging
func (r ApiListGroupAttributesRequest) Prev(prev bool) ApiListGroupAttributesRequest {
	r.prev = &prev
	return r
}

// When true, returns only attributes that conflict with other Group attributes on your Team.
func (r ApiListGroupAttributesRequest) Conflicting(conflicting bool) ApiListGroupAttributesRequest {
	r.conflicting = &conflicting
	return r
}

func (r ApiListGroupAttributesRequest) Execute() (*ListGroupAttributesResponse, *http.Response, error) {
	return r.ApiService.ListGroupAttributesExecute(r)
}

/*
	ListGroupAttributes List all Attributes for a Group

	    Lists all Attributes for a specified Group

This endpoint requires one of the following roles: `resource_admin`, `delegated_resource_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param groupName The name of the Group
	@return ApiListGroupAttributesRequest
*/
func (a *AttributesAPIService) ListGroupAttributes(ctx context.Context, teamName string, groupName string) ApiListGroupAttributesRequest {
	return ApiListGroupAttributesRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
		groupName:  groupName,
	}
}

// Execute executes the request
//
//	@return ListGroupAttributesResponse
func (a *AttributesAPIService) ListGroupAttributesExecute(r ApiListGroupAttributesRequest) (*ListGroupAttributesResponse, *http.Response, error) {
	var (
		traceKey            = "attributesapi.listGroupAttributes"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListGroupAttributesResponse
	)

	localVarPath := "/v1/teams/{team_name}/groups/{group_name}/attributes"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "")
	}
	if r.prev != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prev", r.prev, "")
	}
	if r.conflicting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conflicting", r.conflicting, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiListTeamUserAttributeConflictsRequest struct {
	ctx        context.Context
	ApiService *AttributesAPIService
	teamName   string
	offset     *string
	count      *int32
	descending *bool
	prev       *bool
}

// The offset value for pagination. The **rel&#x3D;\&quot;next\&quot;** and **rel&#x3D;\&quot;prev\&quot;** &#x60;Link&#x60; headers define the offset for subsequent or previous pages.
func (r ApiListTeamUserAttributeConflictsRequest) Offset(offset string) ApiListTeamUserAttributeConflictsRequest {
	r.offset = &offset
	return r
}

// The number of objects per page
func (r ApiListTeamUserAttributeConflictsRequest) Count(count int32) ApiListTeamUserAttributeConflictsRequest {
	r.count = &count
	return r
}

// The object order
func (r ApiListTeamUserAttributeConflictsRequest) Descending(descending bool) ApiListTeamUserAttributeConflictsRequest {
	r.descending = &descending
	return r
}

// The direction of paging
func (r ApiListTeamUserAttributeConflictsRequest) Prev(prev bool) ApiListTeamUserAttributeConflictsRequest {
	r.prev = &prev
	return r
}

func (r ApiListTeamUserAttributeConflictsRequest) Execute() (*ListTeamUserAttributeConflictsResponse, *http.Response, error) {
	return r.ApiService.ListTeamUserAttributeConflictsExecute(r)
}

/*
	ListTeamUserAttributeConflicts List all Attribute Conflicts for a Team

	    Lists all attribute conflicts for your Team

This endpoint requires the following role: `resource_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	@return ApiListTeamUserAttributeConflictsRequest
*/
func (a *AttributesAPIService) ListTeamUserAttributeConflicts(ctx context.Context, teamName string) ApiListTeamUserAttributeConflictsRequest {
	return ApiListTeamUserAttributeConflictsRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
	}
}

// Execute executes the request
//
//	@return ListTeamUserAttributeConflictsResponse
func (a *AttributesAPIService) ListTeamUserAttributeConflictsExecute(r ApiListTeamUserAttributeConflictsRequest) (*ListTeamUserAttributeConflictsResponse, *http.Response, error) {
	var (
		traceKey            = "attributesapi.listTeamUserAttributeConflicts"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListTeamUserAttributeConflictsResponse
	)

	localVarPath := "/v1/teams/{team_name}/attributes/conflicts"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "")
	}
	if r.prev != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prev", r.prev, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiListUserAttributesRequest struct {
	ctx         context.Context
	ApiService  *AttributesAPIService
	teamName    string
	userName    string
	offset      *string
	count       *int32
	descending  *bool
	prev        *bool
	conflicting *bool
}

// The offset value for pagination. The **rel&#x3D;\&quot;next\&quot;** and **rel&#x3D;\&quot;prev\&quot;** &#x60;Link&#x60; headers define the offset for subsequent or previous pages.
func (r ApiListUserAttributesRequest) Offset(offset string) ApiListUserAttributesRequest {
	r.offset = &offset
	return r
}

// The number of objects per page
func (r ApiListUserAttributesRequest) Count(count int32) ApiListUserAttributesRequest {
	r.count = &count
	return r
}

// The object order
func (r ApiListUserAttributesRequest) Descending(descending bool) ApiListUserAttributesRequest {
	r.descending = &descending
	return r
}

// The direction of paging
func (r ApiListUserAttributesRequest) Prev(prev bool) ApiListUserAttributesRequest {
	r.prev = &prev
	return r
}

// When true, returns only attributes that conflict with other User attributes on your Team
func (r ApiListUserAttributesRequest) Conflicting(conflicting bool) ApiListUserAttributesRequest {
	r.conflicting = &conflicting
	return r
}

func (r ApiListUserAttributesRequest) Execute() (*ListUserAttributesResponse, *http.Response, error) {
	return r.ApiService.ListUserAttributesExecute(r)
}

/*
	ListUserAttributes List all Attributes for a User

	    Lists all Attributes for a specified user

This endpoint requires the following role: `resource_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param userName The relevant username
	@return ApiListUserAttributesRequest
*/
func (a *AttributesAPIService) ListUserAttributes(ctx context.Context, teamName string, userName string) ApiListUserAttributesRequest {
	return ApiListUserAttributesRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
		userName:   userName,
	}
}

// Execute executes the request
//
//	@return ListUserAttributesResponse
func (a *AttributesAPIService) ListUserAttributesExecute(r ApiListUserAttributesRequest) (*ListUserAttributesResponse, *http.Response, error) {
	var (
		traceKey            = "attributesapi.listUserAttributes"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListUserAttributesResponse
	)

	localVarPath := "/v1/teams/{team_name}/users/{user_name}/attributes"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_name"+"}", url.PathEscape(parameterValueToString(r.userName, "userName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "")
	}
	if r.prev != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prev", r.prev, "")
	}
	if r.conflicting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conflicting", r.conflicting, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiUpdateGroupAttributeRequest struct {
	ctx                  context.Context
	ApiService           *AttributesAPIService
	teamName             string
	groupName            string
	attributeId          string
	updateGroupAttribute *UpdateGroupAttribute
}

func (r ApiUpdateGroupAttributeRequest) UpdateGroupAttribute(updateGroupAttribute UpdateGroupAttribute) ApiUpdateGroupAttributeRequest {
	r.updateGroupAttribute = &updateGroupAttribute
	return r
}

func (r ApiUpdateGroupAttributeRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateGroupAttributeExecute(r)
}

/*
	UpdateGroupAttribute Update a Group Attribute

	    Updates an Attribute for a Group

This endpoint requires the following role: `resource_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param groupName The name of the Group
	    @param attributeId The UUID of the Attribute
	@return ApiUpdateGroupAttributeRequest
*/
func (a *AttributesAPIService) UpdateGroupAttribute(ctx context.Context, teamName string, groupName string, attributeId string) ApiUpdateGroupAttributeRequest {
	return ApiUpdateGroupAttributeRequest{
		ApiService:  a,
		ctx:         ctx,
		teamName:    teamName,
		groupName:   groupName,
		attributeId: attributeId,
	}
}

// Execute executes the request
func (a *AttributesAPIService) UpdateGroupAttributeExecute(r ApiUpdateGroupAttributeRequest) (*http.Response, error) {
	var (
		traceKey           = "attributesapi.updateGroupAttribute"
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localVarPath := "/v1/teams/{team_name}/groups/{group_name}/attributes/{attribute_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attribute_id"+"}", url.PathEscape(parameterValueToString(r.attributeId, "attributeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateGroupAttribute == nil {
		return nil, reportError("updateGroupAttribute is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateGroupAttribute
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, nil)

	return localVarHTTPResponse, err
}

type ApiUpdateUserAttributeRequest struct {
	ctx             context.Context
	ApiService      *AttributesAPIService
	teamName        string
	userName        string
	attributeId     string
	updateAttribute *UpdateAttribute
}

func (r ApiUpdateUserAttributeRequest) UpdateAttribute(updateAttribute UpdateAttribute) ApiUpdateUserAttributeRequest {
	r.updateAttribute = &updateAttribute
	return r
}

func (r ApiUpdateUserAttributeRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateUserAttributeExecute(r)
}

/*
	UpdateUserAttribute Update a User Attribute

	    Updates an Attribute for a User

This endpoint requires the following role: `resource_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param userName The relevant username
	    @param attributeId The UUID of the Attribute
	@return ApiUpdateUserAttributeRequest
*/
func (a *AttributesAPIService) UpdateUserAttribute(ctx context.Context, teamName string, userName string, attributeId string) ApiUpdateUserAttributeRequest {
	return ApiUpdateUserAttributeRequest{
		ApiService:  a,
		ctx:         ctx,
		teamName:    teamName,
		userName:    userName,
		attributeId: attributeId,
	}
}

// Execute executes the request
func (a *AttributesAPIService) UpdateUserAttributeExecute(r ApiUpdateUserAttributeRequest) (*http.Response, error) {
	var (
		traceKey           = "attributesapi.updateUserAttribute"
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localVarPath := "/v1/teams/{team_name}/users/{user_name}/attributes/{attribute_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_name"+"}", url.PathEscape(parameterValueToString(r.userName, "userName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attribute_id"+"}", url.PathEscape(parameterValueToString(r.attributeId, "attributeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateAttribute == nil {
		return nil, reportError("updateAttribute is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateAttribute
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, nil)

	return localVarHTTPResponse, err
}
