/*
Okta Privileged Access

The Okta Privileged Access API is a control plane used to request operations in Okta Privileged Access (formerly ScaleFT/Advanced Server Access)

API version: 1.0.0
Contact: support@okta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pam

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// WorkloadConnectionsAPIService WorkloadConnectionsAPI service
type WorkloadConnectionsAPIService service

type ApiCreateWorkloadConnectionRequest struct {
	ctx                context.Context
	ApiService         *WorkloadConnectionsAPIService
	teamName           string
	workloadConnection *WorkloadConnection
}

func (r ApiCreateWorkloadConnectionRequest) WorkloadConnection(workloadConnection WorkloadConnection) ApiCreateWorkloadConnectionRequest {
	r.workloadConnection = &workloadConnection
	return r
}

func (r ApiCreateWorkloadConnectionRequest) Execute() (*WorkloadConnection, *http.Response, error) {
	return r.ApiService.CreateWorkloadConnectionExecute(r)
}

/*
CreateWorkloadConnection Create a new workload connection

	Creates a new workload connection

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

	@param teamName The name of your team

@return ApiCreateWorkloadConnectionRequest
*/
func (a *WorkloadConnectionsAPIService) CreateWorkloadConnection(ctx context.Context, teamName string) ApiCreateWorkloadConnectionRequest {
	return ApiCreateWorkloadConnectionRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
	}
}

// Execute executes the request
//
//	@return WorkloadConnection
func (a *WorkloadConnectionsAPIService) CreateWorkloadConnectionExecute(r ApiCreateWorkloadConnectionRequest) (*WorkloadConnection, *http.Response, error) {
	var (
		traceKey            = "workloadconnectionsapi.createWorkloadConnection"
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WorkloadConnection
	)

	localVarPath := "/v1/teams/{team_name}/workload_connections"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.workloadConnection == nil {
		return localVarReturnValue, nil, reportError("workloadConnection is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.workloadConnection
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if err != nil {
		if localVarHTTPResponse == nil {
			return localVarReturnValue, nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return localVarReturnValue, nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		if localVarHTTPResponse.StatusCode == 400 {

			var nonDefaultResponse ErrNonDefaultResponse
			var v BadRequestResponse
			if err := json.Unmarshal(bodyBytes, &v); err != nil {
				return nil, localVarHTTPResponse, err
			}
			nonDefaultResponse.Result = v
			nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
			return nil, localVarHTTPResponse, nonDefaultResponse

		}
		if localVarHTTPResponse.StatusCode == 401 {

			var nonDefaultResponse ErrNonDefaultResponse
			var v UnauthorizedAccessResponse
			if err := json.Unmarshal(bodyBytes, &v); err != nil {
				return nil, localVarHTTPResponse, err
			}
			nonDefaultResponse.Result = v
			nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
			return nil, localVarHTTPResponse, nonDefaultResponse

		}
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		return localVarReturnValue, localVarHTTPResponse, apiError
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiDeleteWorkloadConnectionRequest struct {
	ctx                  context.Context
	ApiService           *WorkloadConnectionsAPIService
	teamName             string
	workloadConnectionId string
}

func (r ApiDeleteWorkloadConnectionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteWorkloadConnectionExecute(r)
}

/*
DeleteWorkloadConnection Delete a workload connection

	Deletes a workload connection by its ID

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

	@param teamName The name of your team
	@param workloadConnectionId The ID of the workload connection

@return ApiDeleteWorkloadConnectionRequest
*/
func (a *WorkloadConnectionsAPIService) DeleteWorkloadConnection(ctx context.Context, teamName string, workloadConnectionId string) ApiDeleteWorkloadConnectionRequest {
	return ApiDeleteWorkloadConnectionRequest{
		ApiService:           a,
		ctx:                  ctx,
		teamName:             teamName,
		workloadConnectionId: workloadConnectionId,
	}
}

// Execute executes the request
func (a *WorkloadConnectionsAPIService) DeleteWorkloadConnectionExecute(r ApiDeleteWorkloadConnectionRequest) (*http.Response, error) {
	var (
		traceKey           = "workloadconnectionsapi.deleteWorkloadConnection"
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localVarPath := "/v1/teams/{team_name}/workload_connections/{workload_connection_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workload_connection_id"+"}", url.PathEscape(parameterValueToString(r.workloadConnectionId, "workloadConnectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, nil)

	if err != nil {
		if localVarHTTPResponse == nil {
			return nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		if localVarHTTPResponse.StatusCode == 401 {

			var nonDefaultResponse ErrNonDefaultResponse
			var v UnauthorizedAccessResponse
			if err := json.Unmarshal(bodyBytes, &v); err != nil {
				return localVarHTTPResponse, err
			}
			nonDefaultResponse.Result = v
			nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
			return localVarHTTPResponse, nonDefaultResponse

		}
		if localVarHTTPResponse.StatusCode == 404 {

			var nonDefaultResponse ErrNonDefaultResponse
			var v NotFoundResponse
			if err := json.Unmarshal(bodyBytes, &v); err != nil {
				return localVarHTTPResponse, err
			}
			nonDefaultResponse.Result = v
			nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
			return localVarHTTPResponse, nonDefaultResponse

		}
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarHTTPResponse, err
		}
		return localVarHTTPResponse, apiError
	}

	return localVarHTTPResponse, err
}

type ApiGetWorkloadConnectionRequest struct {
	ctx                  context.Context
	ApiService           *WorkloadConnectionsAPIService
	teamName             string
	workloadConnectionId string
}

func (r ApiGetWorkloadConnectionRequest) Execute() (*WorkloadConnection, *http.Response, error) {
	return r.ApiService.GetWorkloadConnectionExecute(r)
}

/*
GetWorkloadConnection Retrieve a workload connection

	Retrieves a workload connection by its ID

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

	@param teamName The name of your team
	@param workloadConnectionId The ID of the workload connection

@return ApiGetWorkloadConnectionRequest
*/
func (a *WorkloadConnectionsAPIService) GetWorkloadConnection(ctx context.Context, teamName string, workloadConnectionId string) ApiGetWorkloadConnectionRequest {
	return ApiGetWorkloadConnectionRequest{
		ApiService:           a,
		ctx:                  ctx,
		teamName:             teamName,
		workloadConnectionId: workloadConnectionId,
	}
}

// Execute executes the request
//
//	@return WorkloadConnection
func (a *WorkloadConnectionsAPIService) GetWorkloadConnectionExecute(r ApiGetWorkloadConnectionRequest) (*WorkloadConnection, *http.Response, error) {
	var (
		traceKey            = "workloadconnectionsapi.getWorkloadConnection"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WorkloadConnection
	)

	localVarPath := "/v1/teams/{team_name}/workload_connections/{workload_connection_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workload_connection_id"+"}", url.PathEscape(parameterValueToString(r.workloadConnectionId, "workloadConnectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if err != nil {
		if localVarHTTPResponse == nil {
			return localVarReturnValue, nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return localVarReturnValue, nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		if localVarHTTPResponse.StatusCode == 401 {

			var nonDefaultResponse ErrNonDefaultResponse
			var v UnauthorizedAccessResponse
			if err := json.Unmarshal(bodyBytes, &v); err != nil {
				return nil, localVarHTTPResponse, err
			}
			nonDefaultResponse.Result = v
			nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
			return nil, localVarHTTPResponse, nonDefaultResponse

		}
		if localVarHTTPResponse.StatusCode == 404 {

			var nonDefaultResponse ErrNonDefaultResponse
			var v NotFoundResponse
			if err := json.Unmarshal(bodyBytes, &v); err != nil {
				return nil, localVarHTTPResponse, err
			}
			nonDefaultResponse.Result = v
			nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
			return nil, localVarHTTPResponse, nonDefaultResponse

		}
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		return localVarReturnValue, localVarHTTPResponse, apiError
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiGetWorkloadConnectionAuthzDetailsRequest struct {
	ctx                    context.Context
	ApiService             *WorkloadConnectionsAPIService
	teamName               string
	workloadConnectionName string
	ifNoneMatch            *string
}

// ETag value to determine if the resource has changed. If it matches the current ETag on the server, a 304 Not Modified will be returned.
func (r ApiGetWorkloadConnectionAuthzDetailsRequest) IfNoneMatch(ifNoneMatch string) ApiGetWorkloadConnectionAuthzDetailsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r ApiGetWorkloadConnectionAuthzDetailsRequest) Execute() (*WorkloadConnectionAuthzDetails, *http.Response, error) {
	return r.ApiService.GetWorkloadConnectionAuthzDetailsExecute(r)
}

/*
GetWorkloadConnectionAuthzDetails Retrieve workload connection authorization details

	Retrieves workload connection authorization details by its name

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

	@param teamName The name of your team
	@param workloadConnectionName The name of the workload connection

@return ApiGetWorkloadConnectionAuthzDetailsRequest
*/
func (a *WorkloadConnectionsAPIService) GetWorkloadConnectionAuthzDetails(ctx context.Context, teamName string, workloadConnectionName string) ApiGetWorkloadConnectionAuthzDetailsRequest {
	return ApiGetWorkloadConnectionAuthzDetailsRequest{
		ApiService:             a,
		ctx:                    ctx,
		teamName:               teamName,
		workloadConnectionName: workloadConnectionName,
	}
}

// Execute executes the request
//
//	@return WorkloadConnectionAuthzDetails
func (a *WorkloadConnectionsAPIService) GetWorkloadConnectionAuthzDetailsExecute(r ApiGetWorkloadConnectionAuthzDetailsRequest) (*WorkloadConnectionAuthzDetails, *http.Response, error) {
	var (
		traceKey            = "workloadconnectionsapi.getWorkloadConnectionAuthzDetails"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WorkloadConnectionAuthzDetails
	)

	localVarPath := "/v1/internal/teams/{team_name}/workload_connections/{workload_connection_name}/authz_details"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workload_connection_name"+"}", url.PathEscape(parameterValueToString(r.workloadConnectionName, "workloadConnectionName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "")
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if err != nil {
		if localVarHTTPResponse == nil {
			return localVarReturnValue, nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return localVarReturnValue, nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		if localVarHTTPResponse.StatusCode == 304 {

			var nonDefaultResponse ErrNonDefaultResponse
			var v NotModifiedResponse
			if err := json.Unmarshal(bodyBytes, &v); err != nil {
				return nil, localVarHTTPResponse, err
			}
			nonDefaultResponse.Result = v
			nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
			return nil, localVarHTTPResponse, nonDefaultResponse

		}
		if localVarHTTPResponse.StatusCode == 401 {

			var nonDefaultResponse ErrNonDefaultResponse
			var v UnauthorizedAccessResponse
			if err := json.Unmarshal(bodyBytes, &v); err != nil {
				return nil, localVarHTTPResponse, err
			}
			nonDefaultResponse.Result = v
			nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
			return nil, localVarHTTPResponse, nonDefaultResponse

		}
		if localVarHTTPResponse.StatusCode == 404 {

			var nonDefaultResponse ErrNonDefaultResponse
			var v NotFoundResponse
			if err := json.Unmarshal(bodyBytes, &v); err != nil {
				return nil, localVarHTTPResponse, err
			}
			nonDefaultResponse.Result = v
			nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
			return nil, localVarHTTPResponse, nonDefaultResponse

		}
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		return localVarReturnValue, localVarHTTPResponse, apiError
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiListWorkloadConnectionsRequest struct {
	ctx        context.Context
	ApiService *WorkloadConnectionsAPIService
	teamName   string
}

func (r ApiListWorkloadConnectionsRequest) Execute() (*ListWorkloadConnectionsResponse, *http.Response, error) {
	return r.ApiService.ListWorkloadConnectionsExecute(r)
}

/*
ListWorkloadConnections List all workload connections

	Lists all workload connections

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

	@param teamName The name of your team

@return ApiListWorkloadConnectionsRequest
*/
func (a *WorkloadConnectionsAPIService) ListWorkloadConnections(ctx context.Context, teamName string) ApiListWorkloadConnectionsRequest {
	return ApiListWorkloadConnectionsRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
	}
}

// Execute executes the request
//
//	@return ListWorkloadConnectionsResponse
func (a *WorkloadConnectionsAPIService) ListWorkloadConnectionsExecute(r ApiListWorkloadConnectionsRequest) (*ListWorkloadConnectionsResponse, *http.Response, error) {
	var (
		traceKey            = "workloadconnectionsapi.listWorkloadConnections"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListWorkloadConnectionsResponse
	)

	localVarPath := "/v1/teams/{team_name}/workload_connections"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if err != nil {
		if localVarHTTPResponse == nil {
			return localVarReturnValue, nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return localVarReturnValue, nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		if localVarHTTPResponse.StatusCode == 401 {

			var nonDefaultResponse ErrNonDefaultResponse
			var v UnauthorizedAccessResponse
			if err := json.Unmarshal(bodyBytes, &v); err != nil {
				return nil, localVarHTTPResponse, err
			}
			nonDefaultResponse.Result = v
			nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
			return nil, localVarHTTPResponse, nonDefaultResponse

		}
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		return localVarReturnValue, localVarHTTPResponse, apiError
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiUpdateWorkloadConnectionRequest struct {
	ctx                  context.Context
	ApiService           *WorkloadConnectionsAPIService
	teamName             string
	workloadConnectionId string
	workloadConnection   *WorkloadConnection
}

func (r ApiUpdateWorkloadConnectionRequest) WorkloadConnection(workloadConnection WorkloadConnection) ApiUpdateWorkloadConnectionRequest {
	r.workloadConnection = &workloadConnection
	return r
}

func (r ApiUpdateWorkloadConnectionRequest) Execute() (*WorkloadConnection, *http.Response, error) {
	return r.ApiService.UpdateWorkloadConnectionExecute(r)
}

/*
UpdateWorkloadConnection Update a workload connection

	Updates a workload connection by its ID

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

	@param teamName The name of your team
	@param workloadConnectionId The ID of the workload connection

@return ApiUpdateWorkloadConnectionRequest
*/
func (a *WorkloadConnectionsAPIService) UpdateWorkloadConnection(ctx context.Context, teamName string, workloadConnectionId string) ApiUpdateWorkloadConnectionRequest {
	return ApiUpdateWorkloadConnectionRequest{
		ApiService:           a,
		ctx:                  ctx,
		teamName:             teamName,
		workloadConnectionId: workloadConnectionId,
	}
}

// Execute executes the request
//
//	@return WorkloadConnection
func (a *WorkloadConnectionsAPIService) UpdateWorkloadConnectionExecute(r ApiUpdateWorkloadConnectionRequest) (*WorkloadConnection, *http.Response, error) {
	var (
		traceKey            = "workloadconnectionsapi.updateWorkloadConnection"
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WorkloadConnection
	)

	localVarPath := "/v1/teams/{team_name}/workload_connections/{workload_connection_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workload_connection_id"+"}", url.PathEscape(parameterValueToString(r.workloadConnectionId, "workloadConnectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.workloadConnection == nil {
		return localVarReturnValue, nil, reportError("workloadConnection is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.workloadConnection
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if err != nil {
		if localVarHTTPResponse == nil {
			return localVarReturnValue, nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return localVarReturnValue, nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		if localVarHTTPResponse.StatusCode == 400 {

			var nonDefaultResponse ErrNonDefaultResponse
			var v BadRequestResponse
			if err := json.Unmarshal(bodyBytes, &v); err != nil {
				return nil, localVarHTTPResponse, err
			}
			nonDefaultResponse.Result = v
			nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
			return nil, localVarHTTPResponse, nonDefaultResponse

		}
		if localVarHTTPResponse.StatusCode == 401 {

			var nonDefaultResponse ErrNonDefaultResponse
			var v UnauthorizedAccessResponse
			if err := json.Unmarshal(bodyBytes, &v); err != nil {
				return nil, localVarHTTPResponse, err
			}
			nonDefaultResponse.Result = v
			nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
			return nil, localVarHTTPResponse, nonDefaultResponse

		}
		if localVarHTTPResponse.StatusCode == 404 {

			var nonDefaultResponse ErrNonDefaultResponse
			var v NotFoundResponse
			if err := json.Unmarshal(bodyBytes, &v); err != nil {
				return nil, localVarHTTPResponse, err
			}
			nonDefaultResponse.Result = v
			nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
			return nil, localVarHTTPResponse, nonDefaultResponse

		}
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		return localVarReturnValue, localVarHTTPResponse, apiError
	}

	return localVarReturnValue, localVarHTTPResponse, err
}
