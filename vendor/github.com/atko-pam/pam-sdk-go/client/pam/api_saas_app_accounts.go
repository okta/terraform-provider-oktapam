/*
Okta Privileged Access

The OPA API is a control plane used to request operations in Okta Privileged Access (formerly ScaleFT/Advanced Server Access)

API version: 1.0.0
Contact: support@okta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pam

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// SaasAppAccountsAPIService SaasAppAccountsAPI service
type SaasAppAccountsAPIService service

type ApiGetOktaUDServiceAccountEndUserRequest struct {
	ctx                             context.Context
	ApiService                      *SaasAppAccountsAPIService
	teamName                        string
	oktaUniversalDirectoryAccountId string
}

func (r ApiGetOktaUDServiceAccountEndUserRequest) Execute() (*ServiceAccountEndUser, *http.Response, error) {
	return r.ApiService.GetOktaUDServiceAccountEndUserExecute(r)
}

/*
	GetOktaUDServiceAccountEndUser Get a Okta Universal Directory service account user has access to

	    Gets a Okta Universal Directory service account user has access to based on the security policies

This endpoint requires the following role: `end_user`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param oktaUniversalDirectoryAccountId The UUID of an Okta Universal Directory Account
	@return ApiGetOktaUDServiceAccountEndUserRequest
*/
func (a *SaasAppAccountsAPIService) GetOktaUDServiceAccountEndUser(ctx context.Context, teamName string, oktaUniversalDirectoryAccountId string) ApiGetOktaUDServiceAccountEndUserRequest {
	return ApiGetOktaUDServiceAccountEndUserRequest{
		ApiService:                      a,
		ctx:                             ctx,
		teamName:                        teamName,
		oktaUniversalDirectoryAccountId: oktaUniversalDirectoryAccountId,
	}
}

// Execute executes the request
//
//	@return ServiceAccountEndUser
func (a *SaasAppAccountsAPIService) GetOktaUDServiceAccountEndUserExecute(r ApiGetOktaUDServiceAccountEndUserRequest) (*ServiceAccountEndUser, *http.Response, error) {
	var (
		traceKey            = "saasappaccountsapi.getOktaUDServiceAccountEndUser"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ServiceAccountEndUser
	)

	localVarPath := "/v1/teams/{team_name}/okta_universal_directory_accounts/{okta_universal_directory_account_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"okta_universal_directory_account_id"+"}", url.PathEscape(parameterValueToString(r.oktaUniversalDirectoryAccountId, "oktaUniversalDirectoryAccountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiGetSaaSApplicationServiceAccountEndUserRequest struct {
	ctx               context.Context
	ApiService        *SaasAppAccountsAPIService
	teamName          string
	saasAppInstanceId string
	saasAppAccountId  string
}

func (r ApiGetSaaSApplicationServiceAccountEndUserRequest) Execute() (*ServiceAccountEndUser, *http.Response, error) {
	return r.ApiService.GetSaaSApplicationServiceAccountEndUserExecute(r)
}

/*
	GetSaaSApplicationServiceAccountEndUser Get a SaaS application service account that the user has access to

	    Gets a SaaS application service account that the user has access to based on the security policies

This endpoint requires the following role: `end_user`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param saasAppInstanceId The App Instance ID of SaaS App provisioned to an Okta org
	    @param saasAppAccountId The UUID of a SaaS Application Account
	@return ApiGetSaaSApplicationServiceAccountEndUserRequest
*/
func (a *SaasAppAccountsAPIService) GetSaaSApplicationServiceAccountEndUser(ctx context.Context, teamName string, saasAppInstanceId string, saasAppAccountId string) ApiGetSaaSApplicationServiceAccountEndUserRequest {
	return ApiGetSaaSApplicationServiceAccountEndUserRequest{
		ApiService:        a,
		ctx:               ctx,
		teamName:          teamName,
		saasAppInstanceId: saasAppInstanceId,
		saasAppAccountId:  saasAppAccountId,
	}
}

// Execute executes the request
//
//	@return ServiceAccountEndUser
func (a *SaasAppAccountsAPIService) GetSaaSApplicationServiceAccountEndUserExecute(r ApiGetSaaSApplicationServiceAccountEndUserRequest) (*ServiceAccountEndUser, *http.Response, error) {
	var (
		traceKey            = "saasappaccountsapi.getSaaSApplicationServiceAccountEndUser"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ServiceAccountEndUser
	)

	localVarPath := "/v1/teams/{team_name}/saas_apps/{saas_app_instance_id}/accounts/{saas_app_account_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"saas_app_instance_id"+"}", url.PathEscape(parameterValueToString(r.saasAppInstanceId, "saasAppInstanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"saas_app_account_id"+"}", url.PathEscape(parameterValueToString(r.saasAppAccountId, "saasAppAccountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiGetSaasApplicationAccessibleByUserRequest struct {
	ctx               context.Context
	ApiService        *SaasAppAccountsAPIService
	teamName          string
	saasAppInstanceId string
}

func (r ApiGetSaasApplicationAccessibleByUserRequest) Execute() (*SaasApplicationInstance, *http.Response, error) {
	return r.ApiService.GetSaasApplicationAccessibleByUserExecute(r)
}

/*
	GetSaasApplicationAccessibleByUser Get a SaaS Application instance accessible to the end user

	    Gets a SaaS Application instance that an end user has access to through at least one account based on the security policies

This endpoint requires the following role: `end_user`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param saasAppInstanceId The App Instance ID of SaaS App provisioned to an Okta org
	@return ApiGetSaasApplicationAccessibleByUserRequest
*/
func (a *SaasAppAccountsAPIService) GetSaasApplicationAccessibleByUser(ctx context.Context, teamName string, saasAppInstanceId string) ApiGetSaasApplicationAccessibleByUserRequest {
	return ApiGetSaasApplicationAccessibleByUserRequest{
		ApiService:        a,
		ctx:               ctx,
		teamName:          teamName,
		saasAppInstanceId: saasAppInstanceId,
	}
}

// Execute executes the request
//
//	@return SaasApplicationInstance
func (a *SaasAppAccountsAPIService) GetSaasApplicationAccessibleByUserExecute(r ApiGetSaasApplicationAccessibleByUserRequest) (*SaasApplicationInstance, *http.Response, error) {
	var (
		traceKey            = "saasappaccountsapi.getSaasApplicationAccessibleByUser"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SaasApplicationInstance
	)

	localVarPath := "/v1/teams/{team_name}/saas_apps/{saas_app_instance_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"saas_app_instance_id"+"}", url.PathEscape(parameterValueToString(r.saasAppInstanceId, "saasAppInstanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiListAllSaasAppAccountsForDelegatedSecurityAdminRequest struct {
	ctx             context.Context
	ApiService      *SaasAppAccountsAPIService
	teamName        string
	resourceGroupId string
	contains        *string
	managed         *bool
}

// Only return results that include the specified value
func (r ApiListAllSaasAppAccountsForDelegatedSecurityAdminRequest) Contains(contains string) ApiListAllSaasAppAccountsForDelegatedSecurityAdminRequest {
	r.contains = &contains
	return r
}

// If &#x60;true&#x60;, only return SaaS Application Accounts that support password rotation. If &#x60;false&#x60;, only return SaaS Application Accounts that do not support password rotation.
func (r ApiListAllSaasAppAccountsForDelegatedSecurityAdminRequest) Managed(managed bool) ApiListAllSaasAppAccountsForDelegatedSecurityAdminRequest {
	r.managed = &managed
	return r
}

func (r ApiListAllSaasAppAccountsForDelegatedSecurityAdminRequest) Execute() (*ListAllSaasAppAccountsForDelegatedSecurityAdminResponse, *http.Response, error) {
	return r.ApiService.ListAllSaasAppAccountsForDelegatedSecurityAdminExecute(r)
}

/*
	ListAllSaasAppAccountsForDelegatedSecurityAdmin List all SaaS Application Accounts in a Resource Group

	    Lists all SaaS Application Accounts for the current Security Admin or Delegated Security Admin for the Resource Group

This endpoint requires one of the following roles: `security_admin`, `delegated_security_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param resourceGroupId The UUID of a Resource Group
	@return ApiListAllSaasAppAccountsForDelegatedSecurityAdminRequest
*/
func (a *SaasAppAccountsAPIService) ListAllSaasAppAccountsForDelegatedSecurityAdmin(ctx context.Context, teamName string, resourceGroupId string) ApiListAllSaasAppAccountsForDelegatedSecurityAdminRequest {
	return ApiListAllSaasAppAccountsForDelegatedSecurityAdminRequest{
		ApiService:      a,
		ctx:             ctx,
		teamName:        teamName,
		resourceGroupId: resourceGroupId,
	}
}

// Execute executes the request
//
//	@return ListAllSaasAppAccountsForDelegatedSecurityAdminResponse
func (a *SaasAppAccountsAPIService) ListAllSaasAppAccountsForDelegatedSecurityAdminExecute(r ApiListAllSaasAppAccountsForDelegatedSecurityAdminRequest) (*ListAllSaasAppAccountsForDelegatedSecurityAdminResponse, *http.Response, error) {
	var (
		traceKey            = "saasappaccountsapi.listAllSaasAppAccountsForDelegatedSecurityAdmin"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListAllSaasAppAccountsForDelegatedSecurityAdminResponse
	)

	localVarPath := "/v1/teams/{team_name}/resource_groups/{resource_group_id}/all_saas_app_accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_group_id"+"}", url.PathEscape(parameterValueToString(r.resourceGroupId, "resourceGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contains", r.contains, "")
	}
	if r.managed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "managed", r.managed, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiListAllSaasAppAccountsForSecurityAdminRequest struct {
	ctx        context.Context
	ApiService *SaasAppAccountsAPIService
	teamName   string
	contains   *string
	managed    *bool
}

// Only return results that include the specified value
func (r ApiListAllSaasAppAccountsForSecurityAdminRequest) Contains(contains string) ApiListAllSaasAppAccountsForSecurityAdminRequest {
	r.contains = &contains
	return r
}

// If &#x60;true&#x60;, only return SaaS Application Accounts that support password rotation. If &#x60;false&#x60;, only return SaaS Application Accounts that do not support password rotation.
func (r ApiListAllSaasAppAccountsForSecurityAdminRequest) Managed(managed bool) ApiListAllSaasAppAccountsForSecurityAdminRequest {
	r.managed = &managed
	return r
}

func (r ApiListAllSaasAppAccountsForSecurityAdminRequest) Execute() (*ListAllSaasAppAccountsForSecurityAdminResponse, *http.Response, error) {
	return r.ApiService.ListAllSaasAppAccountsForSecurityAdminExecute(r)
}

/*
	ListAllSaasAppAccountsForSecurityAdmin List all SaaS Application Accounts

	    Lists all SaaS Application Accounts for the current Security Admin

This endpoint requires the following role: `security_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	@return ApiListAllSaasAppAccountsForSecurityAdminRequest
*/
func (a *SaasAppAccountsAPIService) ListAllSaasAppAccountsForSecurityAdmin(ctx context.Context, teamName string) ApiListAllSaasAppAccountsForSecurityAdminRequest {
	return ApiListAllSaasAppAccountsForSecurityAdminRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
	}
}

// Execute executes the request
//
//	@return ListAllSaasAppAccountsForSecurityAdminResponse
func (a *SaasAppAccountsAPIService) ListAllSaasAppAccountsForSecurityAdminExecute(r ApiListAllSaasAppAccountsForSecurityAdminRequest) (*ListAllSaasAppAccountsForSecurityAdminResponse, *http.Response, error) {
	var (
		traceKey            = "saasappaccountsapi.listAllSaasAppAccountsForSecurityAdmin"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListAllSaasAppAccountsForSecurityAdminResponse
	)

	localVarPath := "/v1/teams/{team_name}/all_saas_app_accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contains", r.contains, "")
	}
	if r.managed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "managed", r.managed, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiListOktaUDServiceAccountsEndUserRequest struct {
	ctx        context.Context
	ApiService *SaasAppAccountsAPIService
	teamName   string
	count      *int32
	prev       *bool
	offset     *string
	descending *bool
}

// The number of objects per page
func (r ApiListOktaUDServiceAccountsEndUserRequest) Count(count int32) ApiListOktaUDServiceAccountsEndUserRequest {
	r.count = &count
	return r
}

// The direction of paging
func (r ApiListOktaUDServiceAccountsEndUserRequest) Prev(prev bool) ApiListOktaUDServiceAccountsEndUserRequest {
	r.prev = &prev
	return r
}

// The offset value for pagination. The **rel&#x3D;\&quot;next\&quot;** and **rel&#x3D;\&quot;prev\&quot;** &#x60;Link&#x60; headers define the offset for subsequent or previous pages.
func (r ApiListOktaUDServiceAccountsEndUserRequest) Offset(offset string) ApiListOktaUDServiceAccountsEndUserRequest {
	r.offset = &offset
	return r
}

// The object order
func (r ApiListOktaUDServiceAccountsEndUserRequest) Descending(descending bool) ApiListOktaUDServiceAccountsEndUserRequest {
	r.descending = &descending
	return r
}

func (r ApiListOktaUDServiceAccountsEndUserRequest) Execute() (*ListServiceAccountsEndUserResponse, *http.Response, error) {
	return r.ApiService.ListOktaUDServiceAccountsEndUserExecute(r)
}

/*
	ListOktaUDServiceAccountsEndUser List Okta Universal Directory service accounts user has access to

	    List Okta Universal Directory service accounts user has access to based on the security policies

This endpoint requires the following role: `end_user`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	@return ApiListOktaUDServiceAccountsEndUserRequest
*/
func (a *SaasAppAccountsAPIService) ListOktaUDServiceAccountsEndUser(ctx context.Context, teamName string) ApiListOktaUDServiceAccountsEndUserRequest {
	return ApiListOktaUDServiceAccountsEndUserRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
	}
}

// Execute executes the request
//
//	@return ListServiceAccountsEndUserResponse
func (a *SaasAppAccountsAPIService) ListOktaUDServiceAccountsEndUserExecute(r ApiListOktaUDServiceAccountsEndUserRequest) (*ListServiceAccountsEndUserResponse, *http.Response, error) {
	var (
		traceKey            = "saasappaccountsapi.listOktaUDServiceAccountsEndUser"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListServiceAccountsEndUserResponse
	)

	localVarPath := "/v1/teams/{team_name}/okta_universal_directory_accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.prev != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prev", r.prev, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiListResourceGroupProjectSaasAppAccountsRequest struct {
	ctx             context.Context
	ApiService      *SaasAppAccountsAPIService
	teamName        string
	resourceGroupId string
	projectId       string
	contains        *string
	managed         *bool
}

// Only return results that include the specified value
func (r ApiListResourceGroupProjectSaasAppAccountsRequest) Contains(contains string) ApiListResourceGroupProjectSaasAppAccountsRequest {
	r.contains = &contains
	return r
}

// If &#x60;true&#x60;, only return SaaS Application Accounts that support password rotation. If &#x60;false&#x60;, only return SaaS Application Accounts that do not support password rotation.
func (r ApiListResourceGroupProjectSaasAppAccountsRequest) Managed(managed bool) ApiListResourceGroupProjectSaasAppAccountsRequest {
	r.managed = &managed
	return r
}

func (r ApiListResourceGroupProjectSaasAppAccountsRequest) Execute() (*ListResourceGroupProjectSaasAppAccountsResponse, *http.Response, error) {
	return r.ApiService.ListResourceGroupProjectSaasAppAccountsExecute(r)
}

/*
	ListResourceGroupProjectSaasAppAccounts List all SaaS Application Accounts in a Project

	    Lists all SaaS Application Accounts in a Project in a Resource Group.

This endpoint requires one of the following roles: `resource_admin`, `delegated_resource_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param resourceGroupId The UUID of a Resource Group
	    @param projectId The UUID of a Project
	@return ApiListResourceGroupProjectSaasAppAccountsRequest
*/
func (a *SaasAppAccountsAPIService) ListResourceGroupProjectSaasAppAccounts(ctx context.Context, teamName string, resourceGroupId string, projectId string) ApiListResourceGroupProjectSaasAppAccountsRequest {
	return ApiListResourceGroupProjectSaasAppAccountsRequest{
		ApiService:      a,
		ctx:             ctx,
		teamName:        teamName,
		resourceGroupId: resourceGroupId,
		projectId:       projectId,
	}
}

// Execute executes the request
//
//	@return ListResourceGroupProjectSaasAppAccountsResponse
func (a *SaasAppAccountsAPIService) ListResourceGroupProjectSaasAppAccountsExecute(r ApiListResourceGroupProjectSaasAppAccountsRequest) (*ListResourceGroupProjectSaasAppAccountsResponse, *http.Response, error) {
	var (
		traceKey            = "saasappaccountsapi.listResourceGroupProjectSaasAppAccounts"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListResourceGroupProjectSaasAppAccountsResponse
	)

	localVarPath := "/v1/teams/{team_name}/resource_groups/{resource_group_id}/projects/{project_id}/saas_app_accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_group_id"+"}", url.PathEscape(parameterValueToString(r.resourceGroupId, "resourceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contains", r.contains, "")
	}
	if r.managed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "managed", r.managed, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiListSaaSApplicationServiceAccountsEndUserRequest struct {
	ctx               context.Context
	ApiService        *SaasAppAccountsAPIService
	teamName          string
	saasAppInstanceId string
	count             *int32
	prev              *bool
	offset            *string
	descending        *bool
}

// The number of objects per page
func (r ApiListSaaSApplicationServiceAccountsEndUserRequest) Count(count int32) ApiListSaaSApplicationServiceAccountsEndUserRequest {
	r.count = &count
	return r
}

// The direction of paging
func (r ApiListSaaSApplicationServiceAccountsEndUserRequest) Prev(prev bool) ApiListSaaSApplicationServiceAccountsEndUserRequest {
	r.prev = &prev
	return r
}

// The offset value for pagination. The **rel&#x3D;\&quot;next\&quot;** and **rel&#x3D;\&quot;prev\&quot;** &#x60;Link&#x60; headers define the offset for subsequent or previous pages.
func (r ApiListSaaSApplicationServiceAccountsEndUserRequest) Offset(offset string) ApiListSaaSApplicationServiceAccountsEndUserRequest {
	r.offset = &offset
	return r
}

// The object order
func (r ApiListSaaSApplicationServiceAccountsEndUserRequest) Descending(descending bool) ApiListSaaSApplicationServiceAccountsEndUserRequest {
	r.descending = &descending
	return r
}

func (r ApiListSaaSApplicationServiceAccountsEndUserRequest) Execute() (*ListServiceAccountsEndUserResponse, *http.Response, error) {
	return r.ApiService.ListSaaSApplicationServiceAccountsEndUserExecute(r)
}

/*
	ListSaaSApplicationServiceAccountsEndUser List SaaS application service accounts user has access to

	    List SaaS application service accounts user has access to based on the security policies

This endpoint requires the following role: `end_user`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param saasAppInstanceId The App Instance ID of SaaS App provisioned to an Okta org
	@return ApiListSaaSApplicationServiceAccountsEndUserRequest
*/
func (a *SaasAppAccountsAPIService) ListSaaSApplicationServiceAccountsEndUser(ctx context.Context, teamName string, saasAppInstanceId string) ApiListSaaSApplicationServiceAccountsEndUserRequest {
	return ApiListSaaSApplicationServiceAccountsEndUserRequest{
		ApiService:        a,
		ctx:               ctx,
		teamName:          teamName,
		saasAppInstanceId: saasAppInstanceId,
	}
}

// Execute executes the request
//
//	@return ListServiceAccountsEndUserResponse
func (a *SaasAppAccountsAPIService) ListSaaSApplicationServiceAccountsEndUserExecute(r ApiListSaaSApplicationServiceAccountsEndUserRequest) (*ListServiceAccountsEndUserResponse, *http.Response, error) {
	var (
		traceKey            = "saasappaccountsapi.listSaaSApplicationServiceAccountsEndUser"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListServiceAccountsEndUserResponse
	)

	localVarPath := "/v1/teams/{team_name}/saas_apps/{saas_app_instance_id}/accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"saas_app_instance_id"+"}", url.PathEscape(parameterValueToString(r.saasAppInstanceId, "saasAppInstanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.prev != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prev", r.prev, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiListSaasApplicationsAccessibleByUserRequest struct {
	ctx        context.Context
	ApiService *SaasAppAccountsAPIService
	teamName   string
	count      *int32
	prev       *bool
	offset     *string
	descending *bool
}

// The number of objects per page
func (r ApiListSaasApplicationsAccessibleByUserRequest) Count(count int32) ApiListSaasApplicationsAccessibleByUserRequest {
	r.count = &count
	return r
}

// The direction of paging
func (r ApiListSaasApplicationsAccessibleByUserRequest) Prev(prev bool) ApiListSaasApplicationsAccessibleByUserRequest {
	r.prev = &prev
	return r
}

// The offset value for pagination. The **rel&#x3D;\&quot;next\&quot;** and **rel&#x3D;\&quot;prev\&quot;** &#x60;Link&#x60; headers define the offset for subsequent or previous pages.
func (r ApiListSaasApplicationsAccessibleByUserRequest) Offset(offset string) ApiListSaasApplicationsAccessibleByUserRequest {
	r.offset = &offset
	return r
}

// The object order
func (r ApiListSaasApplicationsAccessibleByUserRequest) Descending(descending bool) ApiListSaasApplicationsAccessibleByUserRequest {
	r.descending = &descending
	return r
}

func (r ApiListSaasApplicationsAccessibleByUserRequest) Execute() (*ListSaasApplicationsAccessibleByUserResponse, *http.Response, error) {
	return r.ApiService.ListSaasApplicationsAccessibleByUserExecute(r)
}

/*
	ListSaasApplicationsAccessibleByUser List SaaS Application instances accessible to the end user

	    List SaaS Application instances that an end user has access to through at least one account based on the security policies

This endpoint requires the following role: `end_user`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	@return ApiListSaasApplicationsAccessibleByUserRequest
*/
func (a *SaasAppAccountsAPIService) ListSaasApplicationsAccessibleByUser(ctx context.Context, teamName string) ApiListSaasApplicationsAccessibleByUserRequest {
	return ApiListSaasApplicationsAccessibleByUserRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
	}
}

// Execute executes the request
//
//	@return ListSaasApplicationsAccessibleByUserResponse
func (a *SaasAppAccountsAPIService) ListSaasApplicationsAccessibleByUserExecute(r ApiListSaasApplicationsAccessibleByUserRequest) (*ListSaasApplicationsAccessibleByUserResponse, *http.Response, error) {
	var (
		traceKey            = "saasappaccountsapi.listSaasApplicationsAccessibleByUser"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListSaasApplicationsAccessibleByUserResponse
	)

	localVarPath := "/v1/teams/{team_name}/saas_apps"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.prev != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prev", r.prev, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiListUAMForSaaSApplicationAccountRequest struct {
	ctx               context.Context
	ApiService        *SaasAppAccountsAPIService
	teamName          string
	saasAppInstanceId string
	saasAppAccountId  string
}

func (r ApiListUAMForSaaSApplicationAccountRequest) Execute() (*ListUAMForServiceAccountResponse, *http.Response, error) {
	return r.ApiService.ListUAMForSaaSApplicationAccountExecute(r)
}

/*
	ListUAMForSaaSApplicationAccount List SaaS application account user access methods

	    List SaaS application account user access methods based on the security policies

This endpoint requires the following role: `end_user`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param saasAppInstanceId The App Instance ID of SaaS App provisioned to an Okta org
	    @param saasAppAccountId The UUID of a SaaS Application Account
	@return ApiListUAMForSaaSApplicationAccountRequest
*/
func (a *SaasAppAccountsAPIService) ListUAMForSaaSApplicationAccount(ctx context.Context, teamName string, saasAppInstanceId string, saasAppAccountId string) ApiListUAMForSaaSApplicationAccountRequest {
	return ApiListUAMForSaaSApplicationAccountRequest{
		ApiService:        a,
		ctx:               ctx,
		teamName:          teamName,
		saasAppInstanceId: saasAppInstanceId,
		saasAppAccountId:  saasAppAccountId,
	}
}

// Execute executes the request
//
//	@return ListUAMForServiceAccountResponse
func (a *SaasAppAccountsAPIService) ListUAMForSaaSApplicationAccountExecute(r ApiListUAMForSaaSApplicationAccountRequest) (*ListUAMForServiceAccountResponse, *http.Response, error) {
	var (
		traceKey            = "saasappaccountsapi.listUAMForSaaSApplicationAccount"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListUAMForServiceAccountResponse
	)

	localVarPath := "/v1/teams/{team_name}/saas_apps/{saas_app_instance_id}/accounts/{saas_app_account_id}/user_access_methods"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"saas_app_instance_id"+"}", url.PathEscape(parameterValueToString(r.saasAppInstanceId, "saasAppInstanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"saas_app_account_id"+"}", url.PathEscape(parameterValueToString(r.saasAppAccountId, "saasAppAccountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiRevealSaasAppAccountPasswordRequest struct {
	ctx               context.Context
	ApiService        *SaasAppAccountsAPIService
	teamName          string
	saasAppInstanceId string
	saasAppAccountId  string
	body              *ServiceAccountsRevealCredentialsRequest
}

func (r ApiRevealSaasAppAccountPasswordRequest) Body(body ServiceAccountsRevealCredentialsRequest) ApiRevealSaasAppAccountPasswordRequest {
	r.body = &body
	return r
}

func (r ApiRevealSaasAppAccountPasswordRequest) Execute() (*ServiceAccountsRevealCredentialsResponse, *http.Response, error) {
	return r.ApiService.RevealSaasAppAccountPasswordExecute(r)
}

/*
	RevealSaasAppAccountPassword Reveal the password for SaaS App Account.

	    Reveals the password belonging to a SaaS App Account (managed & unmanaged) that the end user has access to.

This endpoint requires one of the following roles: `end_user`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param saasAppInstanceId The App Instance ID of SaaS App provisioned to an Okta org
	    @param saasAppAccountId The UUID of a SaaS Application Account
	@return ApiRevealSaasAppAccountPasswordRequest
*/
func (a *SaasAppAccountsAPIService) RevealSaasAppAccountPassword(ctx context.Context, teamName string, saasAppInstanceId string, saasAppAccountId string) ApiRevealSaasAppAccountPasswordRequest {
	return ApiRevealSaasAppAccountPasswordRequest{
		ApiService:        a,
		ctx:               ctx,
		teamName:          teamName,
		saasAppInstanceId: saasAppInstanceId,
		saasAppAccountId:  saasAppAccountId,
	}
}

// Execute executes the request
//
//	@return ServiceAccountsRevealCredentialsResponse
func (a *SaasAppAccountsAPIService) RevealSaasAppAccountPasswordExecute(r ApiRevealSaasAppAccountPasswordRequest) (*ServiceAccountsRevealCredentialsResponse, *http.Response, error) {
	var (
		traceKey            = "saasappaccountsapi.revealSaasAppAccountPassword"
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ServiceAccountsRevealCredentialsResponse
	)

	localVarPath := "/v1/teams/{team_name}/saas_apps/{saas_app_instance_id}/accounts/{saas_app_account_id}/reveal_credentials"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"saas_app_instance_id"+"}", url.PathEscape(parameterValueToString(r.saasAppInstanceId, "saasAppInstanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"saas_app_account_id"+"}", url.PathEscape(parameterValueToString(r.saasAppAccountId, "saasAppAccountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if localVarHTTPResponse == nil && err != nil {
		return localVarReturnValue, nil, err
	}

	if localVarHTTPResponse.StatusCode == 401 {

		localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return nil, localVarHTTPResponse, err
		}

		var nonDefaultResponse ErrNonDefaultResponse
		var v UnauthorizedAccessResponse
		if err := json.Unmarshal(localVarBody, &v); err != nil {
			return nil, localVarHTTPResponse, err
		}
		nonDefaultResponse.Result = v
		nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
		return nil, localVarHTTPResponse, nonDefaultResponse
	}
	if localVarHTTPResponse.StatusCode == 404 {

		localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return nil, localVarHTTPResponse, err
		}

		var nonDefaultResponse ErrNonDefaultResponse
		var v NotFoundResponse
		if err := json.Unmarshal(localVarBody, &v); err != nil {
			return nil, localVarHTTPResponse, err
		}
		nonDefaultResponse.Result = v
		nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
		return nil, localVarHTTPResponse, nonDefaultResponse
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiUpdateSaasAppAccountPasswordRequest struct {
	ctx               context.Context
	ApiService        *SaasAppAccountsAPIService
	teamName          string
	saasAppInstanceId string
	saasAppAccountId  string
	body              *ServiceAccountsUpdateCredentialsRequest
}

func (r ApiUpdateSaasAppAccountPasswordRequest) Body(body ServiceAccountsUpdateCredentialsRequest) ApiUpdateSaasAppAccountPasswordRequest {
	r.body = &body
	return r
}

func (r ApiUpdateSaasAppAccountPasswordRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateSaasAppAccountPasswordExecute(r)
}

/*
	UpdateSaasAppAccountPassword Update the password for SaaS App Account.

	    Updates the password belonging to a SaaS App Account (managed & unmanaged) that the end user has access to.

This endpoint requires one of the following roles: `end_user`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param saasAppInstanceId The App Instance ID of SaaS App provisioned to an Okta org
	    @param saasAppAccountId The UUID of a SaaS Application Account
	@return ApiUpdateSaasAppAccountPasswordRequest
*/
func (a *SaasAppAccountsAPIService) UpdateSaasAppAccountPassword(ctx context.Context, teamName string, saasAppInstanceId string, saasAppAccountId string) ApiUpdateSaasAppAccountPasswordRequest {
	return ApiUpdateSaasAppAccountPasswordRequest{
		ApiService:        a,
		ctx:               ctx,
		teamName:          teamName,
		saasAppInstanceId: saasAppInstanceId,
		saasAppAccountId:  saasAppAccountId,
	}
}

// Execute executes the request
func (a *SaasAppAccountsAPIService) UpdateSaasAppAccountPasswordExecute(r ApiUpdateSaasAppAccountPasswordRequest) (*http.Response, error) {
	var (
		traceKey           = "saasappaccountsapi.updateSaasAppAccountPassword"
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localVarPath := "/v1/teams/{team_name}/saas_apps/{saas_app_instance_id}/accounts/{saas_app_account_id}/credentials"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"saas_app_instance_id"+"}", url.PathEscape(parameterValueToString(r.saasAppInstanceId, "saasAppInstanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"saas_app_account_id"+"}", url.PathEscape(parameterValueToString(r.saasAppAccountId, "saasAppAccountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, nil)

	if localVarHTTPResponse == nil && err != nil {
		return nil, err
	}

	if localVarHTTPResponse.StatusCode == 401 {

		localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarHTTPResponse, err
		}

		var nonDefaultResponse ErrNonDefaultResponse
		var v UnauthorizedAccessResponse
		if err := json.Unmarshal(localVarBody, &v); err != nil {
			return localVarHTTPResponse, err
		}
		nonDefaultResponse.Result = v
		nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
		return localVarHTTPResponse, nonDefaultResponse
	}
	if localVarHTTPResponse.StatusCode == 404 {

		localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarHTTPResponse, err
		}

		var nonDefaultResponse ErrNonDefaultResponse
		var v NotFoundResponse
		if err := json.Unmarshal(localVarBody, &v); err != nil {
			return localVarHTTPResponse, err
		}
		nonDefaultResponse.Result = v
		nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
		return localVarHTTPResponse, nonDefaultResponse
	}

	return localVarHTTPResponse, err
}
