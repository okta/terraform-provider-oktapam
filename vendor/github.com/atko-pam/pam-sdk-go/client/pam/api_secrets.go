/*
Okta Privileged Access

The OPA API is a control plane used to request operations in Okta Privileged Access (formerly ScaleFT/Advanced Server Access)

API version: 1.0.0
Contact: support@okta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pam

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// SecretsAPIService SecretsAPI service
type SecretsAPIService service

type ApiCreateSecretRequest struct {
	ctx                         context.Context
	ApiService                  *SecretsAPIService
	teamName                    string
	resourceGroupId             string
	projectId                   string
	secretCreateOrUpdateRequest *SecretCreateOrUpdateRequest
}

func (r ApiCreateSecretRequest) SecretCreateOrUpdateRequest(secretCreateOrUpdateRequest SecretCreateOrUpdateRequest) ApiCreateSecretRequest {
	r.secretCreateOrUpdateRequest = &secretCreateOrUpdateRequest
	return r
}

func (r ApiCreateSecretRequest) Execute() (*Secret, *http.Response, error) {
	return r.ApiService.CreateSecretExecute(r)
}

/*
	CreateSecret Create a Secret

	    Creates a Secret. Users must be authorized to perform this action by an existing Security Policy.

This endpoint requires one of the following roles: `authenticated_client`, `authenticated_service_user`, `end_user`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param resourceGroupId The UUID of a Resource Group
	    @param projectId The UUID of a Project
	@return ApiCreateSecretRequest
*/
func (a *SecretsAPIService) CreateSecret(ctx context.Context, teamName string, resourceGroupId string, projectId string) ApiCreateSecretRequest {
	return ApiCreateSecretRequest{
		ApiService:      a,
		ctx:             ctx,
		teamName:        teamName,
		resourceGroupId: resourceGroupId,
		projectId:       projectId,
	}
}

// Execute executes the request
//
//	@return Secret
func (a *SecretsAPIService) CreateSecretExecute(r ApiCreateSecretRequest) (*Secret, *http.Response, error) {
	var (
		traceKey            = "secretsapi.createSecret"
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Secret
	)

	localVarPath := "/v1/teams/{team_name}/resource_groups/{resource_group_id}/projects/{project_id}/secrets"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_group_id"+"}", url.PathEscape(parameterValueToString(r.resourceGroupId, "resourceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.secretCreateOrUpdateRequest
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if err != nil {
		if localVarHTTPResponse == nil {
			return localVarReturnValue, nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return localVarReturnValue, nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		if localVarHTTPResponse.StatusCode == 403 {

			var nonDefaultResponse ErrNonDefaultResponse
			var v CreateSecretForbiddenResponse
			if err := json.Unmarshal(bodyBytes, &v); err != nil {
				return nil, localVarHTTPResponse, err
			}
			nonDefaultResponse.Result = v
			nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
			return nil, localVarHTTPResponse, nonDefaultResponse

		}
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		return localVarReturnValue, localVarHTTPResponse, apiError
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiCreateSecretFolderRequest struct {
	ctx                       context.Context
	ApiService                *SecretsAPIService
	teamName                  string
	resourceGroupId           string
	projectId                 string
	secretFolderCreateRequest *SecretFolderCreateRequest
}

func (r ApiCreateSecretFolderRequest) SecretFolderCreateRequest(secretFolderCreateRequest SecretFolderCreateRequest) ApiCreateSecretFolderRequest {
	r.secretFolderCreateRequest = &secretFolderCreateRequest
	return r
}

func (r ApiCreateSecretFolderRequest) Execute() (*SecretFolderResponse, *http.Response, error) {
	return r.ApiService.CreateSecretFolderExecute(r)
}

/*
	CreateSecretFolder Create a Secret Folder

	    Creates a Secret Folder. Users must be authorized to perform this action by an existing Security Policy.

This endpoint requires the following roles: `authenticated_client`, `authenticated_service_user`, `end_user`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param resourceGroupId The UUID of a Resource Group
	    @param projectId The UUID of a Project
	@return ApiCreateSecretFolderRequest
*/
func (a *SecretsAPIService) CreateSecretFolder(ctx context.Context, teamName string, resourceGroupId string, projectId string) ApiCreateSecretFolderRequest {
	return ApiCreateSecretFolderRequest{
		ApiService:      a,
		ctx:             ctx,
		teamName:        teamName,
		resourceGroupId: resourceGroupId,
		projectId:       projectId,
	}
}

// Execute executes the request
//
//	@return SecretFolderResponse
func (a *SecretsAPIService) CreateSecretFolderExecute(r ApiCreateSecretFolderRequest) (*SecretFolderResponse, *http.Response, error) {
	var (
		traceKey            = "secretsapi.createSecretFolder"
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SecretFolderResponse
	)

	localVarPath := "/v1/teams/{team_name}/resource_groups/{resource_group_id}/projects/{project_id}/secret_folders"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_group_id"+"}", url.PathEscape(parameterValueToString(r.resourceGroupId, "resourceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.secretFolderCreateRequest
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if err != nil {
		if localVarHTTPResponse == nil {
			return localVarReturnValue, nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return localVarReturnValue, nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		if localVarHTTPResponse.StatusCode == 403 {

			var nonDefaultResponse ErrNonDefaultResponse
			var v CreateSecretFolderForbiddenResponse
			if err := json.Unmarshal(bodyBytes, &v); err != nil {
				return nil, localVarHTTPResponse, err
			}
			nonDefaultResponse.Result = v
			nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
			return nil, localVarHTTPResponse, nonDefaultResponse

		}
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		return localVarReturnValue, localVarHTTPResponse, apiError
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiDeleteSecretRequest struct {
	ctx             context.Context
	ApiService      *SecretsAPIService
	teamName        string
	resourceGroupId string
	projectId       string
	secretId        string
}

func (r ApiDeleteSecretRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSecretExecute(r)
}

/*
	DeleteSecret Delete a Secret

	    Deletes the specified Secret. Users must be authorized to perform this action by an existing Security Policy.

This endpoint requires one of the following roles: `authenticated_client`, `authenticated_service_user`, `end_user`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param resourceGroupId The UUID of a Resource Group
	    @param projectId The UUID of a Project
	    @param secretId The UUID of a Secret
	@return ApiDeleteSecretRequest
*/
func (a *SecretsAPIService) DeleteSecret(ctx context.Context, teamName string, resourceGroupId string, projectId string, secretId string) ApiDeleteSecretRequest {
	return ApiDeleteSecretRequest{
		ApiService:      a,
		ctx:             ctx,
		teamName:        teamName,
		resourceGroupId: resourceGroupId,
		projectId:       projectId,
		secretId:        secretId,
	}
}

// Execute executes the request
func (a *SecretsAPIService) DeleteSecretExecute(r ApiDeleteSecretRequest) (*http.Response, error) {
	var (
		traceKey           = "secretsapi.deleteSecret"
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localVarPath := "/v1/teams/{team_name}/resource_groups/{resource_group_id}/projects/{project_id}/secrets/{secret_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_group_id"+"}", url.PathEscape(parameterValueToString(r.resourceGroupId, "resourceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_id"+"}", url.PathEscape(parameterValueToString(r.secretId, "secretId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, nil)

	if err != nil {
		if localVarHTTPResponse == nil {
			return nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		if localVarHTTPResponse.StatusCode == 403 {

			var nonDefaultResponse ErrNonDefaultResponse
			var v DeleteSecretForbiddenResponse
			if err := json.Unmarshal(bodyBytes, &v); err != nil {
				return localVarHTTPResponse, err
			}
			nonDefaultResponse.Result = v
			nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
			return localVarHTTPResponse, nonDefaultResponse

		}
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarHTTPResponse, err
		}
		return localVarHTTPResponse, apiError
	}

	return localVarHTTPResponse, err
}

type ApiDeleteSecretFolderRequest struct {
	ctx             context.Context
	ApiService      *SecretsAPIService
	teamName        string
	resourceGroupId string
	projectId       string
	secretFolderId  string
}

func (r ApiDeleteSecretFolderRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSecretFolderExecute(r)
}

/*
	DeleteSecretFolder Delete a Secret Folder

	    Deletes the specified Secret Folder. Users must be authorized to perform this action by an existing Security Policy.

This endpoint requires the following roles: `authenticated_client`, `authenticated_service_user`, `end_user`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param resourceGroupId The UUID of a Resource Group
	    @param projectId The UUID of a Project
	    @param secretFolderId The UUID of a Secret Folder
	@return ApiDeleteSecretFolderRequest
*/
func (a *SecretsAPIService) DeleteSecretFolder(ctx context.Context, teamName string, resourceGroupId string, projectId string, secretFolderId string) ApiDeleteSecretFolderRequest {
	return ApiDeleteSecretFolderRequest{
		ApiService:      a,
		ctx:             ctx,
		teamName:        teamName,
		resourceGroupId: resourceGroupId,
		projectId:       projectId,
		secretFolderId:  secretFolderId,
	}
}

// Execute executes the request
func (a *SecretsAPIService) DeleteSecretFolderExecute(r ApiDeleteSecretFolderRequest) (*http.Response, error) {
	var (
		traceKey           = "secretsapi.deleteSecretFolder"
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localVarPath := "/v1/teams/{team_name}/resource_groups/{resource_group_id}/projects/{project_id}/secret_folders/{secret_folder_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_group_id"+"}", url.PathEscape(parameterValueToString(r.resourceGroupId, "resourceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_folder_id"+"}", url.PathEscape(parameterValueToString(r.secretFolderId, "secretFolderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, nil)

	if err != nil {
		if localVarHTTPResponse == nil {
			return nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		if localVarHTTPResponse.StatusCode == 403 {

			var nonDefaultResponse ErrNonDefaultResponse
			var v DeleteSecretFolderForbiddenResponse
			if err := json.Unmarshal(bodyBytes, &v); err != nil {
				return localVarHTTPResponse, err
			}
			nonDefaultResponse.Result = v
			nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
			return localVarHTTPResponse, nonDefaultResponse

		}
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarHTTPResponse, err
		}
		return localVarHTTPResponse, apiError
	}

	return localVarHTTPResponse, err
}

type ApiGetSecretRequest struct {
	ctx             context.Context
	ApiService      *SecretsAPIService
	teamName        string
	resourceGroupId string
	projectId       string
	secretId        string
}

func (r ApiGetSecretRequest) Execute() (*Secret, *http.Response, error) {
	return r.ApiService.GetSecretExecute(r)
}

/*
	GetSecret Retrieve a Secret

	    Retrieves the specified Secret. Users must be authorized to perform this action by an existing Security Policy.

This endpoint requires one of the following roles: `authenticated_client`, `authenticated_service_user`, `end_user`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param resourceGroupId The UUID of a Resource Group
	    @param projectId The UUID of a Project
	    @param secretId The UUID of a Secret
	@return ApiGetSecretRequest
*/
func (a *SecretsAPIService) GetSecret(ctx context.Context, teamName string, resourceGroupId string, projectId string, secretId string) ApiGetSecretRequest {
	return ApiGetSecretRequest{
		ApiService:      a,
		ctx:             ctx,
		teamName:        teamName,
		resourceGroupId: resourceGroupId,
		projectId:       projectId,
		secretId:        secretId,
	}
}

// Execute executes the request
//
//	@return Secret
func (a *SecretsAPIService) GetSecretExecute(r ApiGetSecretRequest) (*Secret, *http.Response, error) {
	var (
		traceKey            = "secretsapi.getSecret"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Secret
	)

	localVarPath := "/v1/teams/{team_name}/resource_groups/{resource_group_id}/projects/{project_id}/secrets/{secret_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_group_id"+"}", url.PathEscape(parameterValueToString(r.resourceGroupId, "resourceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_id"+"}", url.PathEscape(parameterValueToString(r.secretId, "secretId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if err != nil {
		if localVarHTTPResponse == nil {
			return localVarReturnValue, nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return localVarReturnValue, nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		if localVarHTTPResponse.StatusCode == 403 {

			var nonDefaultResponse ErrNonDefaultResponse
			var v GetSecretForbiddenResponse
			if err := json.Unmarshal(bodyBytes, &v); err != nil {
				return nil, localVarHTTPResponse, err
			}
			nonDefaultResponse.Result = v
			nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
			return nil, localVarHTTPResponse, nonDefaultResponse

		}
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		return localVarReturnValue, localVarHTTPResponse, apiError
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiGetSecretFolderRequest struct {
	ctx             context.Context
	ApiService      *SecretsAPIService
	teamName        string
	resourceGroupId string
	projectId       string
	secretFolderId  string
}

func (r ApiGetSecretFolderRequest) Execute() (*SecretFolderResponse, *http.Response, error) {
	return r.ApiService.GetSecretFolderExecute(r)
}

/*
	GetSecretFolder Retrieve a Secret Folder

	    Retrieves the specified Secret Folder. Users must be authorized to perform this action by an existing Security Policy.

This endpoint requires the following roles: `authenticated_client`, `authenticated_service_user`, `end_user`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param resourceGroupId The UUID of a Resource Group
	    @param projectId The UUID of a Project
	    @param secretFolderId The UUID of a Secret Folder
	@return ApiGetSecretFolderRequest
*/
func (a *SecretsAPIService) GetSecretFolder(ctx context.Context, teamName string, resourceGroupId string, projectId string, secretFolderId string) ApiGetSecretFolderRequest {
	return ApiGetSecretFolderRequest{
		ApiService:      a,
		ctx:             ctx,
		teamName:        teamName,
		resourceGroupId: resourceGroupId,
		projectId:       projectId,
		secretFolderId:  secretFolderId,
	}
}

// Execute executes the request
//
//	@return SecretFolderResponse
func (a *SecretsAPIService) GetSecretFolderExecute(r ApiGetSecretFolderRequest) (*SecretFolderResponse, *http.Response, error) {
	var (
		traceKey            = "secretsapi.getSecretFolder"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SecretFolderResponse
	)

	localVarPath := "/v1/teams/{team_name}/resource_groups/{resource_group_id}/projects/{project_id}/secret_folders/{secret_folder_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_group_id"+"}", url.PathEscape(parameterValueToString(r.resourceGroupId, "resourceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_folder_id"+"}", url.PathEscape(parameterValueToString(r.secretFolderId, "secretFolderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if err != nil {
		if localVarHTTPResponse == nil {
			return localVarReturnValue, nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return localVarReturnValue, nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		if localVarHTTPResponse.StatusCode == 403 {

			var nonDefaultResponse ErrNonDefaultResponse
			var v GetSecretFolderForbiddenResponse
			if err := json.Unmarshal(bodyBytes, &v); err != nil {
				return nil, localVarHTTPResponse, err
			}
			nonDefaultResponse.Result = v
			nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
			return nil, localVarHTTPResponse, nonDefaultResponse

		}
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		return localVarReturnValue, localVarHTTPResponse, apiError
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiListSecretFolderItemsRequest struct {
	ctx             context.Context
	ApiService      *SecretsAPIService
	teamName        string
	resourceGroupId string
	projectId       string
	secretFolderId  string
	count           *int32
	descending      *bool
	offset          *string
	prev            *bool
}

// The number of objects per page
func (r ApiListSecretFolderItemsRequest) Count(count int32) ApiListSecretFolderItemsRequest {
	r.count = &count
	return r
}

// The object order
func (r ApiListSecretFolderItemsRequest) Descending(descending bool) ApiListSecretFolderItemsRequest {
	r.descending = &descending
	return r
}

// The offset value for pagination. The **rel&#x3D;\&quot;next\&quot;** and **rel&#x3D;\&quot;prev\&quot;** &#x60;Link&#x60; headers define the offset for subsequent or previous pages.
func (r ApiListSecretFolderItemsRequest) Offset(offset string) ApiListSecretFolderItemsRequest {
	r.offset = &offset
	return r
}

// The direction of paging
func (r ApiListSecretFolderItemsRequest) Prev(prev bool) ApiListSecretFolderItemsRequest {
	r.prev = &prev
	return r
}

func (r ApiListSecretFolderItemsRequest) Execute() (*ListSecretFolderItemsResponse, *http.Response, error) {
	return r.ApiService.ListSecretFolderItemsExecute(r)
}

/*
	ListSecretFolderItems List all items in a Secret Folder

	    Lists all items in a Secret Folder. Users must be authorized to perform this action by an existing Security Policy.

This endpoint requires the following roles: `authenticated_client`, `authenticated_service_user`, `end_user`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param resourceGroupId The UUID of a Resource Group
	    @param projectId The UUID of a Project
	    @param secretFolderId The UUID of a Secret Folder
	@return ApiListSecretFolderItemsRequest
*/
func (a *SecretsAPIService) ListSecretFolderItems(ctx context.Context, teamName string, resourceGroupId string, projectId string, secretFolderId string) ApiListSecretFolderItemsRequest {
	return ApiListSecretFolderItemsRequest{
		ApiService:      a,
		ctx:             ctx,
		teamName:        teamName,
		resourceGroupId: resourceGroupId,
		projectId:       projectId,
		secretFolderId:  secretFolderId,
	}
}

// Execute executes the request
//
//	@return ListSecretFolderItemsResponse
func (a *SecretsAPIService) ListSecretFolderItemsExecute(r ApiListSecretFolderItemsRequest) (*ListSecretFolderItemsResponse, *http.Response, error) {
	var (
		traceKey            = "secretsapi.listSecretFolderItems"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListSecretFolderItemsResponse
	)

	localVarPath := "/v1/teams/{team_name}/resource_groups/{resource_group_id}/projects/{project_id}/secret_folders/{secret_folder_id}/items"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_group_id"+"}", url.PathEscape(parameterValueToString(r.resourceGroupId, "resourceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_folder_id"+"}", url.PathEscape(parameterValueToString(r.secretFolderId, "secretFolderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.prev != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prev", r.prev, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if err != nil {
		if localVarHTTPResponse == nil {
			return localVarReturnValue, nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return localVarReturnValue, nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		if localVarHTTPResponse.StatusCode == 403 {

			var nonDefaultResponse ErrNonDefaultResponse
			var v ListSecretFolderItemsForbiddenResponse
			if err := json.Unmarshal(bodyBytes, &v); err != nil {
				return nil, localVarHTTPResponse, err
			}
			nonDefaultResponse.Result = v
			nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
			return nil, localVarHTTPResponse, nonDefaultResponse

		}
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		return localVarReturnValue, localVarHTTPResponse, apiError
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiListTopLevelSecretFoldersForProjectRequest struct {
	ctx             context.Context
	ApiService      *SecretsAPIService
	teamName        string
	resourceGroupId string
	projectId       string
}

func (r ApiListTopLevelSecretFoldersForProjectRequest) Execute() (*ListTopLevelSecretFoldersForProjectResponse, *http.Response, error) {
	return r.ApiService.ListTopLevelSecretFoldersForProjectExecute(r)
}

/*
	ListTopLevelSecretFoldersForProject List top-level Secret Folders for a Project

	    Lists all top-level Secret Folders for a Project. Users must be authorized to perform this action by an existing Security Policy.

This endpoint requires the following roles: `authenticated_client`, `authenticated_service_user`, `end_user`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param resourceGroupId The UUID of a Resource Group
	    @param projectId The UUID of a Project
	@return ApiListTopLevelSecretFoldersForProjectRequest
*/
func (a *SecretsAPIService) ListTopLevelSecretFoldersForProject(ctx context.Context, teamName string, resourceGroupId string, projectId string) ApiListTopLevelSecretFoldersForProjectRequest {
	return ApiListTopLevelSecretFoldersForProjectRequest{
		ApiService:      a,
		ctx:             ctx,
		teamName:        teamName,
		resourceGroupId: resourceGroupId,
		projectId:       projectId,
	}
}

// Execute executes the request
//
//	@return ListTopLevelSecretFoldersForProjectResponse
func (a *SecretsAPIService) ListTopLevelSecretFoldersForProjectExecute(r ApiListTopLevelSecretFoldersForProjectRequest) (*ListTopLevelSecretFoldersForProjectResponse, *http.Response, error) {
	var (
		traceKey            = "secretsapi.listTopLevelSecretFoldersForProject"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListTopLevelSecretFoldersForProjectResponse
	)

	localVarPath := "/v1/teams/{team_name}/resource_groups/{resource_group_id}/projects/{project_id}/secret_folders"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_group_id"+"}", url.PathEscape(parameterValueToString(r.resourceGroupId, "resourceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if err != nil {
		if localVarHTTPResponse == nil {
			return localVarReturnValue, nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return localVarReturnValue, nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		if localVarHTTPResponse.StatusCode == 403 {

			var nonDefaultResponse ErrNonDefaultResponse
			var v ListTopLevelSecretFoldersForProjectForbiddenResponse
			if err := json.Unmarshal(bodyBytes, &v); err != nil {
				return nil, localVarHTTPResponse, err
			}
			nonDefaultResponse.Result = v
			nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
			return nil, localVarHTTPResponse, nonDefaultResponse

		}
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		return localVarReturnValue, localVarHTTPResponse, apiError
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiListTopLevelSecretFoldersForTeamRequest struct {
	ctx        context.Context
	ApiService *SecretsAPIService
	teamName   string
}

func (r ApiListTopLevelSecretFoldersForTeamRequest) Execute() (*ListTopLevelSecretFoldersForTeamResponse, *http.Response, error) {
	return r.ApiService.ListTopLevelSecretFoldersForTeamExecute(r)
}

/*
	ListTopLevelSecretFoldersForTeam List top-level Secret Folders for Team

	    Lists all top-level Secret Folders for a Team

This endpoint requires the following roles: `security_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	@return ApiListTopLevelSecretFoldersForTeamRequest
*/
func (a *SecretsAPIService) ListTopLevelSecretFoldersForTeam(ctx context.Context, teamName string) ApiListTopLevelSecretFoldersForTeamRequest {
	return ApiListTopLevelSecretFoldersForTeamRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
	}
}

// Execute executes the request
//
//	@return ListTopLevelSecretFoldersForTeamResponse
func (a *SecretsAPIService) ListTopLevelSecretFoldersForTeamExecute(r ApiListTopLevelSecretFoldersForTeamRequest) (*ListTopLevelSecretFoldersForTeamResponse, *http.Response, error) {
	var (
		traceKey            = "secretsapi.listTopLevelSecretFoldersForTeam"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListTopLevelSecretFoldersForTeamResponse
	)

	localVarPath := "/v1/teams/{team_name}/secret_folders"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if err != nil {
		if localVarHTTPResponse == nil {
			return localVarReturnValue, nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return localVarReturnValue, nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		return localVarReturnValue, localVarHTTPResponse, apiError
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiListTopLevelSecretFoldersForUserRequest struct {
	ctx        context.Context
	ApiService *SecretsAPIService
	teamName   string
	count      *int32
	descending *bool
	offset     *string
	prev       *bool
}

// The number of objects per page
func (r ApiListTopLevelSecretFoldersForUserRequest) Count(count int32) ApiListTopLevelSecretFoldersForUserRequest {
	r.count = &count
	return r
}

// The object order
func (r ApiListTopLevelSecretFoldersForUserRequest) Descending(descending bool) ApiListTopLevelSecretFoldersForUserRequest {
	r.descending = &descending
	return r
}

// The offset value for pagination. The **rel&#x3D;\&quot;next\&quot;** and **rel&#x3D;\&quot;prev\&quot;** &#x60;Link&#x60; headers define the offset for subsequent or previous pages.
func (r ApiListTopLevelSecretFoldersForUserRequest) Offset(offset string) ApiListTopLevelSecretFoldersForUserRequest {
	r.offset = &offset
	return r
}

// The direction of paging
func (r ApiListTopLevelSecretFoldersForUserRequest) Prev(prev bool) ApiListTopLevelSecretFoldersForUserRequest {
	r.prev = &prev
	return r
}

func (r ApiListTopLevelSecretFoldersForUserRequest) Execute() (*ListTopLevelSecretFoldersForUserResponse, *http.Response, error) {
	return r.ApiService.ListTopLevelSecretFoldersForUserExecute(r)
}

/*
	ListTopLevelSecretFoldersForUser List top-level Secret Folders for User

	    Lists all top-level Secret Folders for a User. Users must be authorized to perform this action by an existing Security Policy.

This endpoint requires one of the following roles: `authenticated_client`, `authenticated_service_user`, `end_user`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	@return ApiListTopLevelSecretFoldersForUserRequest
*/
func (a *SecretsAPIService) ListTopLevelSecretFoldersForUser(ctx context.Context, teamName string) ApiListTopLevelSecretFoldersForUserRequest {
	return ApiListTopLevelSecretFoldersForUserRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
	}
}

// Execute executes the request
//
//	@return ListTopLevelSecretFoldersForUserResponse
func (a *SecretsAPIService) ListTopLevelSecretFoldersForUserExecute(r ApiListTopLevelSecretFoldersForUserRequest) (*ListTopLevelSecretFoldersForUserResponse, *http.Response, error) {
	var (
		traceKey            = "secretsapi.listTopLevelSecretFoldersForUser"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListTopLevelSecretFoldersForUserResponse
	)

	localVarPath := "/v1/teams/{team_name}/secrets"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.prev != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prev", r.prev, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if err != nil {
		if localVarHTTPResponse == nil {
			return localVarReturnValue, nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return localVarReturnValue, nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		return localVarReturnValue, localVarHTTPResponse, apiError
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiResolveSecretOrFolderRequest struct {
	ctx                          context.Context
	ApiService                   *SecretsAPIService
	teamName                     string
	resolveSecretOrFolderRequest *ResolveSecretOrFolderRequest
}

func (r ApiResolveSecretOrFolderRequest) ResolveSecretOrFolderRequest(resolveSecretOrFolderRequest ResolveSecretOrFolderRequest) ApiResolveSecretOrFolderRequest {
	r.resolveSecretOrFolderRequest = &resolveSecretOrFolderRequest
	return r
}

func (r ApiResolveSecretOrFolderRequest) Execute() (*ResolveSecretOrFolderResponse, *http.Response, error) {
	return r.ApiService.ResolveSecretOrFolderExecute(r)
}

/*
	ResolveSecretOrFolder Resolve Secret or Folder

	    Resolves the ID or path for a Secret or Secret Folder. Users must be authorized to perform this action by an existing Security Policy.

To resolve the ID, the request must include the named path. To resolve the path, the request must include the ID.

This endpoint requires one of the following roles: `authenticated_client`, `authenticated_service_user`, `security_admin`, `delegated_security_admin`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	@return ApiResolveSecretOrFolderRequest
*/
func (a *SecretsAPIService) ResolveSecretOrFolder(ctx context.Context, teamName string) ApiResolveSecretOrFolderRequest {
	return ApiResolveSecretOrFolderRequest{
		ApiService: a,
		ctx:        ctx,
		teamName:   teamName,
	}
}

// Execute executes the request
//
//	@return ResolveSecretOrFolderResponse
func (a *SecretsAPIService) ResolveSecretOrFolderExecute(r ApiResolveSecretOrFolderRequest) (*ResolveSecretOrFolderResponse, *http.Response, error) {
	var (
		traceKey            = "secretsapi.resolveSecretOrFolder"
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ResolveSecretOrFolderResponse
	)

	localVarPath := "/v1/teams/{team_name}/resolve_secret"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resolveSecretOrFolderRequest
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if err != nil {
		if localVarHTTPResponse == nil {
			return localVarReturnValue, nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return localVarReturnValue, nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		return localVarReturnValue, localVarHTTPResponse, apiError
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiRevealSecretRequest struct {
	ctx                 context.Context
	ApiService          *SecretsAPIService
	teamName            string
	resourceGroupId     string
	projectId           string
	secretId            string
	secretRevealRequest *SecretRevealRequest
}

func (r ApiRevealSecretRequest) SecretRevealRequest(secretRevealRequest SecretRevealRequest) ApiRevealSecretRequest {
	r.secretRevealRequest = &secretRevealRequest
	return r
}

func (r ApiRevealSecretRequest) Execute() (*SecretRevealResponse, *http.Response, error) {
	return r.ApiService.RevealSecretExecute(r)
}

/*
	RevealSecret Reveal a Secret

	    Reveals the specified Secret. Users must be authorized to perform this action by an existing Security Policy.

This endpoint requires one of the following roles: `authenticated_client`, `authenticated_service_user`, `end_user`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param resourceGroupId The UUID of a Resource Group
	    @param projectId The UUID of a Project
	    @param secretId The UUID of a Secret
	@return ApiRevealSecretRequest
*/
func (a *SecretsAPIService) RevealSecret(ctx context.Context, teamName string, resourceGroupId string, projectId string, secretId string) ApiRevealSecretRequest {
	return ApiRevealSecretRequest{
		ApiService:      a,
		ctx:             ctx,
		teamName:        teamName,
		resourceGroupId: resourceGroupId,
		projectId:       projectId,
		secretId:        secretId,
	}
}

// Execute executes the request
//
//	@return SecretRevealResponse
func (a *SecretsAPIService) RevealSecretExecute(r ApiRevealSecretRequest) (*SecretRevealResponse, *http.Response, error) {
	var (
		traceKey            = "secretsapi.revealSecret"
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SecretRevealResponse
	)

	localVarPath := "/v1/teams/{team_name}/resource_groups/{resource_group_id}/projects/{project_id}/secrets/{secret_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_group_id"+"}", url.PathEscape(parameterValueToString(r.resourceGroupId, "resourceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_id"+"}", url.PathEscape(parameterValueToString(r.secretId, "secretId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.secretRevealRequest
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if err != nil {
		if localVarHTTPResponse == nil {
			return localVarReturnValue, nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return localVarReturnValue, nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		if localVarHTTPResponse.StatusCode == 403 {

			var nonDefaultResponse ErrNonDefaultResponse
			var v RevealSecretForbiddenResponse
			if err := json.Unmarshal(bodyBytes, &v); err != nil {
				return nil, localVarHTTPResponse, err
			}
			nonDefaultResponse.Result = v
			nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
			return nil, localVarHTTPResponse, nonDefaultResponse

		}
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		return localVarReturnValue, localVarHTTPResponse, apiError
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiUpdateSecretRequest struct {
	ctx                         context.Context
	ApiService                  *SecretsAPIService
	teamName                    string
	resourceGroupId             string
	projectId                   string
	secretId                    string
	secretCreateOrUpdateRequest *SecretCreateOrUpdateRequest
}

func (r ApiUpdateSecretRequest) SecretCreateOrUpdateRequest(secretCreateOrUpdateRequest SecretCreateOrUpdateRequest) ApiUpdateSecretRequest {
	r.secretCreateOrUpdateRequest = &secretCreateOrUpdateRequest
	return r
}

func (r ApiUpdateSecretRequest) Execute() (*Secret, *http.Response, error) {
	return r.ApiService.UpdateSecretExecute(r)
}

/*
	UpdateSecret Update a Secret

	    Updates the specified Secret. Users must be authorized to perform this action by an existing Security Policy.

This endpoint requires one of the following roles: `authenticated_client`, `authenticated_service_user`, `end_user`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param resourceGroupId The UUID of a Resource Group
	    @param projectId The UUID of a Project
	    @param secretId The UUID of a Secret
	@return ApiUpdateSecretRequest
*/
func (a *SecretsAPIService) UpdateSecret(ctx context.Context, teamName string, resourceGroupId string, projectId string, secretId string) ApiUpdateSecretRequest {
	return ApiUpdateSecretRequest{
		ApiService:      a,
		ctx:             ctx,
		teamName:        teamName,
		resourceGroupId: resourceGroupId,
		projectId:       projectId,
		secretId:        secretId,
	}
}

// Execute executes the request
//
//	@return Secret
func (a *SecretsAPIService) UpdateSecretExecute(r ApiUpdateSecretRequest) (*Secret, *http.Response, error) {
	var (
		traceKey            = "secretsapi.updateSecret"
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Secret
	)

	localVarPath := "/v1/teams/{team_name}/resource_groups/{resource_group_id}/projects/{project_id}/secrets/{secret_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_group_id"+"}", url.PathEscape(parameterValueToString(r.resourceGroupId, "resourceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_id"+"}", url.PathEscape(parameterValueToString(r.secretId, "secretId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.secretCreateOrUpdateRequest
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if err != nil {
		if localVarHTTPResponse == nil {
			return localVarReturnValue, nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return localVarReturnValue, nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		if localVarHTTPResponse.StatusCode == 403 {

			var nonDefaultResponse ErrNonDefaultResponse
			var v UpdateSecretForbiddenResponse
			if err := json.Unmarshal(bodyBytes, &v); err != nil {
				return nil, localVarHTTPResponse, err
			}
			nonDefaultResponse.Result = v
			nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
			return nil, localVarHTTPResponse, nonDefaultResponse

		}
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		return localVarReturnValue, localVarHTTPResponse, apiError
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiUpdateSecretFolderRequest struct {
	ctx                       context.Context
	ApiService                *SecretsAPIService
	teamName                  string
	resourceGroupId           string
	projectId                 string
	secretFolderId            string
	secretFolderUpdateRequest *SecretFolderUpdateRequest
}

func (r ApiUpdateSecretFolderRequest) SecretFolderUpdateRequest(secretFolderUpdateRequest SecretFolderUpdateRequest) ApiUpdateSecretFolderRequest {
	r.secretFolderUpdateRequest = &secretFolderUpdateRequest
	return r
}

func (r ApiUpdateSecretFolderRequest) Execute() (*SecretFolderResponse, *http.Response, error) {
	return r.ApiService.UpdateSecretFolderExecute(r)
}

/*
	UpdateSecretFolder Update a Secret Folder

	    Updates the specified Secret Folder. Users must be authorized to perform this action by an existing Security Policy.

This endpoint requires the following roles: `authenticated_client`, `authenticated_service_user`, `end_user`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param teamName The name of your Team
	    @param resourceGroupId The UUID of a Resource Group
	    @param projectId The UUID of a Project
	    @param secretFolderId The UUID of a Secret Folder
	@return ApiUpdateSecretFolderRequest
*/
func (a *SecretsAPIService) UpdateSecretFolder(ctx context.Context, teamName string, resourceGroupId string, projectId string, secretFolderId string) ApiUpdateSecretFolderRequest {
	return ApiUpdateSecretFolderRequest{
		ApiService:      a,
		ctx:             ctx,
		teamName:        teamName,
		resourceGroupId: resourceGroupId,
		projectId:       projectId,
		secretFolderId:  secretFolderId,
	}
}

// Execute executes the request
//
//	@return SecretFolderResponse
func (a *SecretsAPIService) UpdateSecretFolderExecute(r ApiUpdateSecretFolderRequest) (*SecretFolderResponse, *http.Response, error) {
	var (
		traceKey            = "secretsapi.updateSecretFolder"
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SecretFolderResponse
	)

	localVarPath := "/v1/teams/{team_name}/resource_groups/{resource_group_id}/projects/{project_id}/secret_folders/{secret_folder_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_name"+"}", url.PathEscape(parameterValueToString(r.teamName, "teamName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_group_id"+"}", url.PathEscape(parameterValueToString(r.resourceGroupId, "resourceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_folder_id"+"}", url.PathEscape(parameterValueToString(r.secretFolderId, "secretFolderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.secretFolderUpdateRequest
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if err != nil {
		if localVarHTTPResponse == nil {
			return localVarReturnValue, nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return localVarReturnValue, nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		if localVarHTTPResponse.StatusCode == 403 {

			var nonDefaultResponse ErrNonDefaultResponse
			var v UpdateSecretFolderForbiddenResponse
			if err := json.Unmarshal(bodyBytes, &v); err != nil {
				return nil, localVarHTTPResponse, err
			}
			nonDefaultResponse.Result = v
			nonDefaultResponse.StatusCode = localVarHTTPResponse.StatusCode
			return nil, localVarHTTPResponse, nonDefaultResponse

		}
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		return localVarReturnValue, localVarHTTPResponse, apiError
	}

	return localVarReturnValue, localVarHTTPResponse, err
}
