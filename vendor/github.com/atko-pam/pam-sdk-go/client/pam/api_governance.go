/*
Okta Privileged Access

The Okta Privileged Access API is a control plane used to request operations in Okta Privileged Access (formerly ScaleFT/Advanced Server Access)

API version: 1.0.0
Contact: support@okta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pam

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// GovernanceAPIService GovernanceAPI service
type GovernanceAPIService service

type ApiComputeGovernanceCampaignResultsRequest struct {
	ctx          context.Context
	ApiService   *GovernanceAPIService
	resourceType GovernanceResourceType
	resourceId   string
	after        *string
	limit        *int32
}

// The cursor to use for pagination. It is an opaque string that specifies your current location in the list and is obtained from the &#x60;Link&#x60; response header. Only &#x60;Link.self&#x60; and &#x60;Link.next&#x60; headers are defined. Backwards pagination is not supported. (used by monolith)
func (r ApiComputeGovernanceCampaignResultsRequest) After(after string) ApiComputeGovernanceCampaignResultsRequest {
	r.after = &after
	return r
}

// A limit on the number of objects to return (used by monolith)
func (r ApiComputeGovernanceCampaignResultsRequest) Limit(limit int32) ApiComputeGovernanceCampaignResultsRequest {
	r.limit = &limit
	return r
}

func (r ApiComputeGovernanceCampaignResultsRequest) Execute() (*GovernanceCampaignResults, *http.Response, error) {
	return r.ApiService.ComputeGovernanceCampaignResultsExecute(r)
}

/*
	ComputeGovernanceCampaignResults Retrieves campaign results for the specified resource of type `resource_type`

	    Checks groups that have access to the specified resource of type `resource_type` and identified by

`resource_id`, and then returns the results. Campaign results include high-level metadata about the requested
resource, as well as the list of  `groups` that have access to the resource through policy assignments.
Pagination is applied to the group list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param resourceType Specifies the governance resource type
	    @param resourceId Specifies a resource ID to retrieve campaign results for
	@return ApiComputeGovernanceCampaignResultsRequest
*/
func (a *GovernanceAPIService) ComputeGovernanceCampaignResults(ctx context.Context, resourceType GovernanceResourceType, resourceId string) ApiComputeGovernanceCampaignResultsRequest {
	return ApiComputeGovernanceCampaignResultsRequest{
		ApiService:   a,
		ctx:          ctx,
		resourceType: resourceType,
		resourceId:   resourceId,
	}
}

// Execute executes the request
//
//	@return GovernanceCampaignResults
func (a *GovernanceAPIService) ComputeGovernanceCampaignResultsExecute(r ApiComputeGovernanceCampaignResultsRequest) (*GovernanceCampaignResults, *http.Response, error) {
	var (
		traceKey            = "governanceapi.computeGovernanceCampaignResults"
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GovernanceCampaignResults
	)

	localVarPath := "/v1/governance/campaign/{resource_type}/{resource_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"resource_type"+"}", url.PathEscape(parameterValueToString(r.resourceType, "resourceType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_id"+"}", url.PathEscape(parameterValueToString(r.resourceId, "resourceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if err != nil {
		if localVarHTTPResponse == nil {
			return localVarReturnValue, nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return localVarReturnValue, nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		return localVarReturnValue, localVarHTTPResponse, apiError
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiListGovernanceContainersRequest struct {
	ctx           context.Context
	ApiService    *GovernanceAPIService
	containerType GovernanceContainerType
	q             *string
}

// Searches the records for a matching value (used by monolith)
func (r ApiListGovernanceContainersRequest) Q(q string) ApiListGovernanceContainersRequest {
	r.q = &q
	return r
}

func (r ApiListGovernanceContainersRequest) Execute() ([]GovernanceContainer, *http.Response, error) {
	return r.ApiService.ListGovernanceContainersExecute(r)
}

/*
	ListGovernanceContainers List all containers of the specified `container_type`

	    Lists all containers by the specified `container_type` parameter.

These containers are implicitly filtered on the Okta org URL and the Okta Privileged Access team.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	    @param containerType Specifies the container type that encapsulates the resources
	@return ApiListGovernanceContainersRequest
*/
func (a *GovernanceAPIService) ListGovernanceContainers(ctx context.Context, containerType GovernanceContainerType) ApiListGovernanceContainersRequest {
	return ApiListGovernanceContainersRequest{
		ApiService:    a,
		ctx:           ctx,
		containerType: containerType,
	}
}

// Execute executes the request
//
//	@return []GovernanceContainer
func (a *GovernanceAPIService) ListGovernanceContainersExecute(r ApiListGovernanceContainersRequest) ([]GovernanceContainer, *http.Response, error) {
	var (
		traceKey            = "governanceapi.listGovernanceContainers"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []GovernanceContainer
	)

	localVarPath := "/v1/governance/containers/{container_type}"
	localVarPath = strings.Replace(localVarPath, "{"+"container_type"+"}", url.PathEscape(parameterValueToString(r.containerType, "containerType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if err != nil {
		if localVarHTTPResponse == nil {
			return localVarReturnValue, nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return localVarReturnValue, nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		return localVarReturnValue, localVarHTTPResponse, apiError
	}

	return localVarReturnValue, localVarHTTPResponse, err
}

type ApiListGovernanceResourcesRequest struct {
	ctx           context.Context
	ApiService    *GovernanceAPIService
	containerType GovernanceContainerType
	containerId   string
	resourceType  GovernanceResourceType
	after         *string
	limit         *int32
	q             *string
}

// The cursor to use for pagination. It is an opaque string that specifies your current location in the list and is obtained from the &#x60;Link&#x60; response header. Only &#x60;Link.self&#x60; and &#x60;Link.next&#x60; headers are defined. Backwards pagination is not supported. (used by monolith)
func (r ApiListGovernanceResourcesRequest) After(after string) ApiListGovernanceResourcesRequest {
	r.after = &after
	return r
}

// A limit on the number of objects to return (used by monolith)
func (r ApiListGovernanceResourcesRequest) Limit(limit int32) ApiListGovernanceResourcesRequest {
	r.limit = &limit
	return r
}

// Searches the records for a matching value (used by monolith)
func (r ApiListGovernanceResourcesRequest) Q(q string) ApiListGovernanceResourcesRequest {
	r.q = &q
	return r
}

func (r ApiListGovernanceResourcesRequest) Execute() ([]GovernanceResource, *http.Response, error) {
	return r.ApiService.ListGovernanceResourcesExecute(r)
}

/*
	ListGovernanceResources List all resources of the specified `resource_type` within the specified container

	    Lists all resources of the type specified in the `resource_type` parameter.

The resources themselves are encapsulated within the container specified by `container_type` and `container_id`.
Although `resource_type` can usually be implied by `container_type`, there might be instances when a container can
encapsulate multiple types. The combination of `resource_type` and `container_type` must be valid.

List of allowed `resource_type` values for each `container_type`:
- `saas_app_instance`
  - `service_account`

- `group`

  - `user`

    @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
    @param containerType Specifies the container type that encapsulates the resources
    @param containerId Specifies a container ID to filter encapsulated resources by
    @param resourceType Specifies the governance resource type
    @return ApiListGovernanceResourcesRequest
*/
func (a *GovernanceAPIService) ListGovernanceResources(ctx context.Context, containerType GovernanceContainerType, containerId string, resourceType GovernanceResourceType) ApiListGovernanceResourcesRequest {
	return ApiListGovernanceResourcesRequest{
		ApiService:    a,
		ctx:           ctx,
		containerType: containerType,
		containerId:   containerId,
		resourceType:  resourceType,
	}
}

// Execute executes the request
//
//	@return []GovernanceResource
func (a *GovernanceAPIService) ListGovernanceResourcesExecute(r ApiListGovernanceResourcesRequest) ([]GovernanceResource, *http.Response, error) {
	var (
		traceKey            = "governanceapi.listGovernanceResources"
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []GovernanceResource
	)

	localVarPath := "/v1/governance/containers/{container_type}/{container_id}/resources/{resource_type}"
	localVarPath = strings.Replace(localVarPath, "{"+"container_type"+"}", url.PathEscape(parameterValueToString(r.containerType, "containerType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"container_id"+"}", url.PathEscape(parameterValueToString(r.containerId, "containerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_type"+"}", url.PathEscape(parameterValueToString(r.resourceType, "resourceType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHTTPResponse, err := a.client.callAPI(r.ctx, traceKey, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles, &localVarReturnValue)

	if err != nil {
		if localVarHTTPResponse == nil {
			return localVarReturnValue, nil, err
		}

		// read and unmarshal error response into right struct
		bodyBytes, err := io.ReadAll(localVarHTTPResponse.Body)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		if err := localVarHTTPResponse.Body.Close(); err != nil {
			return localVarReturnValue, nil, err
		}
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewReader(bodyBytes)) //Reset body for the caller
		var apiError APIError
		if err := json.Unmarshal(bodyBytes, &apiError); err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
		return localVarReturnValue, localVarHTTPResponse, apiError
	}

	return localVarReturnValue, localVarHTTPResponse, err
}
